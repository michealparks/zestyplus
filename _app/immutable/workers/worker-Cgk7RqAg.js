(function(){"use strict";let R=0;class c{id;type;x;y;z;vx;vy;vz;grid=void 0;localVelocity={x:0,y:0,z:0};static FLOCK_ENTITY=1;static OBSTACLE_ENTITY=1;constructor(t,i=0,e=0,s=0,h=0,o=0,n=0){this.id=++R,this.type=t,this.x=i,this.y=e,this.z=s,this.vx=h,this.vy=o,this.vz=n}setGrid(t){this.grid=t}getType(){return this.type}getVelocity(){return Math.sqrt(this.vx*this.vx+this.vy*this.vy+this.vz*this.vz)}checkVelocity(t=1){const i=this.getVelocity();i>t&&i>0&&(this.vx=t*this.vx/i,this.vy=t*this.vy/i,this.vz=t*this.vz/i)}addVelocity(t,i,e){this.vx+=t,this.vy+=i,this.vz+=e}move(t,i,e,s){this.checkVelocity(t);let h=this.x+this.vx,o=this.y+this.vy,n=this.z+this.vz;h=Math.max(0,h),h=Math.min(i,h),o=Math.max(0,o),o=Math.min(e,o),n=Math.max(0,n),n=Math.min(s,n),this.grid?.moveEntity(this,h,o,n)}getDistance(t){const i=this.x-t.x,e=this.y-t.y,s=this.z-t.z;return Math.sqrt(i*i+e*e+s*s)}serialize(){const{id:t,type:i,x:e,y:s,z:h,vx:o,vy:n,vz:l}=this;return{id:t,type:i,x:e,y:s,z:h,vx:o,vy:n,vz:l}}updateData(t){this.id==t.id&&(this.vx=t.vx,this.vy=t.vy,this.vz=t.vz,this.grid?.moveEntity(this,t.x,t.y,t.z))}static deserialize(t){const i=new c(t.type,t.x,t.y,t.z,t.vx,t.vy,t.vz);return i.id=t.id,i}}class E{worldSize;cellSize;cellRowCount;cellCount;entityList=[];constructor(t,i){this.worldSize=t,this.cellSize=i,this.cellRowCount=this.worldSize/this.cellSize|0,this.cellCount=this.cellRowCount*this.cellRowCount*this.cellRowCount,this.entityList=[];for(let e=0;e<this.cellCount;e+=1)this.entityList[e]=[]}getWorldSize(){return this.worldSize}getGridRowCount(){return this.cellRowCount}getGridIndex(t,i,e){let s=t/this.cellSize|0,h=i/this.cellSize|0,o=e/this.cellSize|0;return s<0?s=0:s>this.cellRowCount-1&&(s=this.cellRowCount-1),h<0?h=0:h>this.cellRowCount-1&&(h=this.cellRowCount-1),o<0?o=0:o>this.cellRowCount-1&&(o=this.cellRowCount-1),s+h*this.cellRowCount+o*this.cellRowCount*this.cellRowCount|0}addEntity(t){const i=this.getGridIndex(t.x,t.y,t.z)|0;t.setGrid(this),this.entityList[i].push(t)}removeEntity(t){const i=this.getGridIndex(t.x,t.y,t.z)|0,e=this.entityList[i],s=e.indexOf(t);if(s==-1)throw"removeEntity() can not find the entity to be removed!";e.splice(s,1),t.setGrid(void 0)}moveEntity(t,i,e,s){const h=this.getGridIndex(t.x,t.y,t.z)|0,o=this.getGridIndex(i,e,s)|0;if(h==o){t.x=i,t.y=e,t.z=s;return}const n=this.entityList[h],l=n.indexOf(t);if(l==-1)throw"moveEntity() can not find the entity to be removed!";n.splice(l,1),t.x=i,t.y=e,t.z=s,this.entityList[o].push(t)}getEntitiesInGrid(t,i,e){const s=this.getGridIndex(t,i,e)|0;return this.entityList[s]}getEntitiesInGridIndex(t){if(t<0||t>=this.cellCount)throw"getEntitiesInGridIndex() out of bounds!";return this.entityList[t|0]}getEntitiesInCube(t,i,e,s,h){const o=this.getGridIndex(t-s,i-s,e-s),n=this.getGridIndex(t+s,i-s,e-s),l=this.getGridIndex(t-s,i+s,e-s),d=this.getGridIndex(t+s,i+s,e+s),a=o,u=n-o+1,x=(l-o)/this.cellRowCount+1|0,p=(d-o)/(this.cellRowCount*this.cellRowCount)+1|0;for(let b=0;b<p;b++)for(let m=0;m<x;m++)for(let v=0;v<u;v++){const y=a+b*this.cellRowCount*this.cellRowCount+m*this.cellRowCount+v;if(y>=this.cellCount)continue;const z=this.entityList[y],w=z.length;for(let f=0;f<w;f++){const r=z[f];r!==void 0&&r.x>=t-s&&r.x<=t+s&&r.y>=i-s&&r.y<=i+s&&r.z>=e-s&&r.z<=e+s&&h(r)}}}}class g{grid;subDivisionCount;flockEntities=[];obstacleEntities=[];boundaryX;boundaryY;boundaryZ;aligmentWeight=2;cohesionWeight=4;separationWeight=.3;maxEntitySpeed=5;aligmentRadius=100;cohesionRadius=100;separationRadius=100;obstacleRadius=100;constructor(t=500,i=500,e=500,s=1){const h=Math.max(t,i,e);this.grid=new E(h,h/s),this.subDivisionCount=s,this.boundaryX=t,this.boundaryY=i,this.boundaryZ=e}addFlockEntity(t){this.grid.addEntity(t),this.flockEntities.push(t)}getFlockEntities(){return this.flockEntities}addObstacleEntity(t){this.grid.addEntity(t),this.obstacleEntities.push(t)}getObstacleEntities(){return this.obstacleEntities}getBoundary(){return[this.boundaryX,this.boundaryY,this.boundaryZ]}setMaxSpeed(t){this.maxEntitySpeed=t}setAligmentWeight(t){this.aligmentWeight=t}setCohesionWeight(t){this.cohesionWeight=t}setSeparationWeight(t){this.separationWeight=t}setBoundary(t,i,e){this.boundaryX=t,this.boundaryY=i,this.boundaryZ=e}iterate(t=0,i=this.flockEntities.length){for(let e=t;e<i;e++){const s=this.flockEntities[e],h=this.computeAlignment(s),o=this.computeCohesion(s),n=this.computeSeparation(s),l=this.computeObstacles(s),d=this.aligmentWeight*h[0]+this.cohesionWeight*o[0]+50*this.separationWeight*n[0]+100*l[0],a=this.aligmentWeight*h[1]+this.cohesionWeight*o[1]+50*this.separationWeight*n[1]+100*l[1],u=this.aligmentWeight*h[2]+this.cohesionWeight*o[2]+50*this.separationWeight*n[2]+100*l[2];s.addVelocity(d,a,u),s.move(this.maxEntitySpeed,this.boundaryX,this.boundaryY,this.boundaryZ)}}computeAlignment(t){let i=0,e=0,s=0,h=0;if(this.grid.getEntitiesInCube(t.x,t.y,t.z,this.aligmentRadius,o=>{o!=t&&o.getType()==c.FLOCK_ENTITY&&t.getDistance(o)<this.aligmentRadius&&(h++,i+=o.vx,e+=o.vy,s+=o.vz)}),h>0){i/=h,e/=h,s/=h;const o=Math.sqrt(i*i+e*e+s*s);o>0&&(i/=o,e/=o,s/=o)}return[i,e,s]}computeCohesion(t){let i=0,e=0,s=0,h=0;if(this.grid.getEntitiesInCube(t.x,t.y,t.z,this.cohesionRadius,o=>{o!=t&&o.getType()==c.FLOCK_ENTITY&&t.getDistance(o)<this.cohesionRadius&&(h++,i+=o.x,e+=o.y,s+=o.z)}),h>0){i/=h,e/=h,s/=h,i=i-t.x,e=e-t.y,s=s-t.z;const o=Math.sqrt(i*i+e*e+s*s);o>0&&(i/=o,e/=o,s/=o)}return[i,e,s]}computeSeparation(t){let i=0,e=0,s=0;return this.grid.getEntitiesInCube(t.x,t.y,t.z,this.separationRadius,h=>{let o=t.getDistance(h);if(o<=0&&(o=.01),h!=t&&h.getType()==c.FLOCK_ENTITY&&o<this.separationRadius){const n=t.x-h.x,l=t.y-h.y,d=t.z-h.z;i+=n/o/o,e+=l/o/o,s+=d/o/o}}),[i,e,s]}computeObstacles(t){let i=0,e=0,s=0;this.grid.getEntitiesInCube(t.x,t.y,t.z,this.obstacleRadius,d=>{const a=t.getDistance(d);if(a>0&&d.getType()==c.OBSTACLE_ENTITY&&a<this.obstacleRadius){const u=t.x-d.x,x=t.y-d.y,p=t.z-d.z;i+=u/a/a,e+=x/a/a,s+=p/a/a}});const h=this.obstacleRadius/4,o=this.boundaryX-t.x,n=this.boundaryY-t.y,l=this.boundaryZ-t.z;return t.x<h&&Math.abs(t.x)>0?i+=1/t.x:o<h&&o>0&&(i-=1/o),t.y<h&&Math.abs(t.y)>0?e+=1/t.y:n<h&&n>0&&(e-=1/n),t.z<h&&Math.abs(t.z)>0?s+=1/t.z:l<h&&l>0&&(s-=1/l),[i,e,s]}serialize(){const t=[],i=[];return this.flockEntities.forEach(e=>{t.push(e.serialize())}),this.obstacleEntities.forEach(e=>{i.push(e.serialize())}),{subDivisionCount:this.subDivisionCount,boundaryX:this.boundaryX,boundaryY:this.boundaryY,boundaryZ:this.boundaryZ,flockEntities:t,obstacleEntities:i,aligmentWeight:this.aligmentWeight,cohesionWeight:this.cohesionWeight,separationWeight:this.separationWeight,maxEntitySpeed:this.maxEntitySpeed,aligmentRadius:this.aligmentRadius,cohesionRadius:this.cohesionRadius,separationRadius:this.separationRadius,obstacleRadius:this.obstacleRadius}}serializeBoidsData(t=0,i=this.flockEntities.length){const e=[];for(let s=t;s<i;s++)e.push(this.flockEntities[s].serialize());return{start:t,flockEntities:e}}applyBoidsData(t){const{start:i,flockEntities:e}=t;for(let s=0;s<e.length;s++){const h=this.flockEntities[i+s],o=e[s];h.id==o.id?h.updateData(o):console.log("ids do not match!")}}static deserialize(t){const i=new g(t.boundaryX,t.boundaryY,t.boundaryZ,t.subDivisionCount);return i.aligmentWeight=t.aligmentWeight,i.cohesionWeight=t.cohesionWeight,i.separationWeight=t.separationWeight,i.maxEntitySpeed=t.maxEntitySpeed,i.aligmentRadius=t.aligmentRadius,i.cohesionRadius=t.cohesionRadius,i.separationRadius=t.separationRadius,i.obstacleRadius=t.obstacleRadius,t.flockEntities.forEach(e=>{const s=c.deserialize(e);i.addFlockEntity(s)}),t.obstacleEntities.forEach(e=>{const s=c.deserialize(e);i.addObstacleEntity(s)}),i}}class W{boidsController=void 0;initializeBoidsController(t){this.boidsController=g.deserialize(t)}iterateBoidsController(t,i,e){if(!this.boidsController)return;this.boidsController.aligmentWeight=e.aligmentWeight,this.boidsController.cohesionWeight=e.cohesionWeight,this.boidsController.separationWeight=e.separationWeight,this.boidsController.maxEntitySpeed=e.maxEntitySpeed,this.boidsController.iterate(t,i);const s=this.boidsController.serializeBoidsData(t,i);postMessage({action:"iterateCompleted",data:s})}updateBoidsData(t){this.boidsController?.applyBoidsData(t)}onMessage(t){t.data.action=="initialData"?this.initializeBoidsController(t.data.data):t.data.action=="iterate"?this.iterateBoidsController(t.data.start,t.data.end,t.data.config):t.data.action=="updateBoidsData"&&this.updateBoidsData(t.data.data)}}const C=new W;onmessage=C.onMessage.bind(C)})();
