import{c as Y,b as R,t as ie}from"./disclose-version.DFxnx1AN.js";import{B as oe,a8 as I,n as Pe,D as re,aa as Fe,T as j,ab as Me,W as ae,u as le,a9 as Q}from"./runtime.BxeNZxLl.js";import{e as ge,i as Ce}from"./each.Dtb_ZQQj.js";import{c as U}from"./svelte-component.C7V4StSs.js";import{p as O,a as ne,s as Ve,r as _e}from"./props.CvCzEa8T.js";import{V as w,L as xe,P as Z,b2 as be,p as Te,F as ce,M as se,G as De,Q as Se,ay as ke,aN as Ae,Y as Ee,b1 as Be}from"./three.module.iKKkBh6O.js";import{d as ze,e as Le,w as Re,T as H,a as Ie,u as je}from"./T.BojAtv_L.js";import{W as He}from"./World.BToOzcib.js";import{u as Ne,a as Oe,b as qe,c as Ge,d as We,l as Qe,f as Ue,o as Ye,A as he,e as Je,i as we}from"./createCollidersFromChildren.3deb0VN8.js";import{s as Ke}from"./snippet.AXKrw6tU.js";import{o as Xe,a as Ze}from"./index-client.DixpdGuH.js";import{i as $e}from"./if.DA9MOHmj.js";import{L as et}from"./Lightformer.C-GXGN2k.js";import{a as tt}from"./auth.svelte.CMqokhwd.js";import{l as nt}from"./MathUtils.DS64O8Kj.js";const $=0,st=1,it=new w,ue=new xe,ee=new Z,de=new w,X=new be;class ot{constructor(){this.tolerance=-1,this.faces=[],this.newFaces=[],this.assigned=new me,this.unassigned=new me,this.vertices=[]}setFromPoints(e){if(e.length>=4){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.vertices.push(new rt(e[t]));this.compute()}return this}setFromObject(e){const t=[];return e.updateMatrixWorld(!0),e.traverse(function(n){const o=n.geometry;if(o!==void 0){const s=o.attributes.position;if(s!==void 0)for(let i=0,a=s.count;i<a;i++){const l=new w;l.fromBufferAttribute(s,i).applyMatrix4(n.matrixWorld),t.push(l)}}}),this.setFromPoints(t)}containsPoint(e){const t=this.faces;for(let n=0,o=t.length;n<o;n++)if(t[n].distanceToPoint(e)>this.tolerance)return!1;return!0}intersectRay(e,t){const n=this.faces;let o=-1/0,s=1/0;for(let i=0,a=n.length;i<a;i++){const l=n[i],c=l.distanceToPoint(e.origin),h=l.normal.dot(e.direction);if(c>0&&h>=0)return null;const f=h!==0?-c/h:0;if(!(f<=0)&&(h>0?s=Math.min(f,s):o=Math.max(f,o),o>s))return null}return o!==-1/0?e.at(o,t):e.at(s,t),t}intersectsRay(e){return this.intersectRay(e,it)!==null}makeEmpty(){return this.faces=[],this.vertices=[],this}addVertexToFace(e,t){return e.face=t,t.outside===null?this.assigned.append(e):this.assigned.insertBefore(t.outside,e),t.outside=e,this}removeVertexFromFace(e,t){return e===t.outside&&(e.next!==null&&e.next.face===t?t.outside=e.next:t.outside=null),this.assigned.remove(e),this}removeAllVerticesFromFace(e){if(e.outside!==null){const t=e.outside;let n=e.outside;for(;n.next!==null&&n.next.face===e;)n=n.next;return this.assigned.removeSubList(t,n),t.prev=n.next=null,e.outside=null,t}}deleteFaceVertices(e,t){const n=this.removeAllVerticesFromFace(e);if(n!==void 0)if(t===void 0)this.unassigned.appendChain(n);else{let o=n;do{const s=o.next;t.distanceToPoint(o.point)>this.tolerance?this.addVertexToFace(o,t):this.unassigned.append(o),o=s}while(o!==null)}return this}resolveUnassignedPoints(e){if(this.unassigned.isEmpty()===!1){let t=this.unassigned.first();do{const n=t.next;let o=this.tolerance,s=null;for(let i=0;i<e.length;i++){const a=e[i];if(a.mark===$){const l=a.distanceToPoint(t.point);if(l>o&&(o=l,s=a),o>1e3*this.tolerance)break}}s!==null&&this.addVertexToFace(t,s),t=n}while(t!==null)}return this}computeExtremes(){const e=new w,t=new w,n=[],o=[];for(let s=0;s<3;s++)n[s]=o[s]=this.vertices[0];e.copy(this.vertices[0].point),t.copy(this.vertices[0].point);for(let s=0,i=this.vertices.length;s<i;s++){const a=this.vertices[s],l=a.point;for(let c=0;c<3;c++)l.getComponent(c)<e.getComponent(c)&&(e.setComponent(c,l.getComponent(c)),n[c]=a);for(let c=0;c<3;c++)l.getComponent(c)>t.getComponent(c)&&(t.setComponent(c,l.getComponent(c)),o[c]=a)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(e.x),Math.abs(t.x))+Math.max(Math.abs(e.y),Math.abs(t.y))+Math.max(Math.abs(e.z),Math.abs(t.z))),{min:n,max:o}}computeInitialHull(){const e=this.vertices,t=this.computeExtremes(),n=t.min,o=t.max;let s=0,i=0;for(let r=0;r<3;r++){const p=o[r].point.getComponent(r)-n[r].point.getComponent(r);p>s&&(s=p,i=r)}const a=n[i],l=o[i];let c,h;s=0,ue.set(a.point,l.point);for(let r=0,p=this.vertices.length;r<p;r++){const d=e[r];if(d!==a&&d!==l){ue.closestPointToPoint(d.point,!0,de);const g=de.distanceToSquared(d.point);g>s&&(s=g,c=d)}}s=-1,ee.setFromCoplanarPoints(a.point,l.point,c.point);for(let r=0,p=this.vertices.length;r<p;r++){const d=e[r];if(d!==a&&d!==l&&d!==c){const g=Math.abs(ee.distanceToPoint(d.point));g>s&&(s=g,h=d)}}const f=[];if(ee.distanceToPoint(h.point)<0){f.push(D.create(a,l,c),D.create(h,l,a),D.create(h,c,l),D.create(h,a,c));for(let r=0;r<3;r++){const p=(r+1)%3;f[r+1].getEdge(2).setTwin(f[0].getEdge(p)),f[r+1].getEdge(1).setTwin(f[p+1].getEdge(0))}}else{f.push(D.create(a,c,l),D.create(h,a,l),D.create(h,l,c),D.create(h,c,a));for(let r=0;r<3;r++){const p=(r+1)%3;f[r+1].getEdge(2).setTwin(f[0].getEdge((3-r)%3)),f[r+1].getEdge(0).setTwin(f[p+1].getEdge(1))}}for(let r=0;r<4;r++)this.faces.push(f[r]);for(let r=0,p=e.length;r<p;r++){const d=e[r];if(d!==a&&d!==l&&d!==c&&d!==h){s=this.tolerance;let g=null;for(let v=0;v<4;v++){const M=this.faces[v].distanceToPoint(d.point);M>s&&(s=M,g=this.faces[v])}g!==null&&this.addVertexToFace(d,g)}}return this}reindexFaces(){const e=[];for(let t=0;t<this.faces.length;t++){const n=this.faces[t];n.mark===$&&e.push(n)}return this.faces=e,this}nextVertexToAdd(){if(this.assigned.isEmpty()===!1){let e,t=0;const n=this.assigned.first().face;let o=n.outside;do{const s=n.distanceToPoint(o.point);s>t&&(t=s,e=o),o=o.next}while(o!==null&&o.face===n);return e}}computeHorizon(e,t,n,o){this.deleteFaceVertices(n),n.mark=st;let s;t===null?s=t=n.getEdge(0):s=t.next;do{const i=s.twin,a=i.face;a.mark===$&&(a.distanceToPoint(e)>this.tolerance?this.computeHorizon(e,i,a,o):o.push(s)),s=s.next}while(s!==t);return this}addAdjoiningFace(e,t){const n=D.create(e,t.tail(),t.head());return this.faces.push(n),n.getEdge(-1).setTwin(t.twin),n.getEdge(0)}addNewFaces(e,t){this.newFaces=[];let n=null,o=null;for(let s=0;s<t.length;s++){const i=t[s],a=this.addAdjoiningFace(e,i);n===null?n=a:a.next.setTwin(o),this.newFaces.push(a.face),o=a}return n.next.setTwin(o),this}addVertexToHull(e){const t=[];return this.unassigned.clear(),this.removeVertexFromFace(e,e.face),this.computeHorizon(e.point,null,e.face,t),this.addNewFaces(e,t),this.resolveUnassignedPoints(this.newFaces),this}cleanup(){return this.assigned.clear(),this.unassigned.clear(),this.newFaces=[],this}compute(){let e;for(this.computeInitialHull();(e=this.nextVertexToAdd())!==void 0;)this.addVertexToHull(e);return this.reindexFaces(),this.cleanup(),this}}class D{constructor(){this.normal=new w,this.midpoint=new w,this.area=0,this.constant=0,this.outside=null,this.mark=$,this.edge=null}static create(e,t,n){const o=new D,s=new te(e,o),i=new te(t,o),a=new te(n,o);return s.next=a.prev=i,i.next=s.prev=a,a.next=i.prev=s,o.edge=s,o.compute()}getEdge(e){let t=this.edge;for(;e>0;)t=t.next,e--;for(;e<0;)t=t.prev,e++;return t}compute(){const e=this.edge.tail(),t=this.edge.head(),n=this.edge.next.head();return X.set(e.point,t.point,n.point),X.getNormal(this.normal),X.getMidpoint(this.midpoint),this.area=X.getArea(),this.constant=this.normal.dot(this.midpoint),this}distanceToPoint(e){return this.normal.dot(e)-this.constant}}class te{constructor(e,t){this.vertex=e,this.prev=null,this.next=null,this.twin=null,this.face=t}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){const e=this.head(),t=this.tail();return t!==null?t.point.distanceTo(e.point):-1}lengthSquared(){const e=this.head(),t=this.tail();return t!==null?t.point.distanceToSquared(e.point):-1}setTwin(e){return this.twin=e,e.twin=this,this}}class rt{constructor(e){this.point=e,this.prev=null,this.next=null,this.face=null}}class me{constructor(){this.head=null,this.tail=null}first(){return this.head}last(){return this.tail}clear(){return this.head=this.tail=null,this}insertBefore(e,t){return t.prev=e.prev,t.next=e,t.prev===null?this.head=t:t.prev.next=t,e.prev=t,this}insertAfter(e,t){return t.prev=e,t.next=e.next,t.next===null?this.tail=t:t.next.prev=t,e.next=t,this}append(e){return this.head===null?this.head=e:this.tail.next=e,e.prev=this.tail,e.next=null,this.tail=e,this}appendChain(e){for(this.head===null?this.head=e:this.tail.next=e,e.prev=this.tail;e.next!==null;)e=e.next;return this.tail=e,this}remove(e){return e.prev===null?this.head=e.next:e.prev.next=e.next,e.next===null?this.tail=e.prev:e.next.prev=e.prev,this}removeSubList(e,t){return e.prev===null?this.head=t.next:e.prev.next=t.next,t.next===null?this.tail=e.prev:t.next.prev=e.prev,this}isEmpty(){return this.head===null}}class fe extends Te{constructor(e=[]){super();const t=[],n=[],s=new ot().setFromPoints(e).faces;for(let i=0;i<s.length;i++){const a=s[i];let l=a.edge;do{const c=l.head().point;t.push(c.x,c.y,c.z),n.push(a.normal.x,a.normal.y,a.normal.z),l=l.next}while(l!==a.edge)}this.setAttribute("position",new ce(t,3)),this.setAttribute("normal",new ce(n,3))}}const at=new w;class J{constructor(e=1.4,t=1e-4){this.minSizeForBreak=e,this.smallDelta=t,this.tempLine1=new xe,this.tempPlane1=new Z,this.tempPlane2=new Z,this.tempPlane_Cut=new Z,this.tempCM1=new w,this.tempCM2=new w,this.tempVector3=new w,this.tempVector3_2=new w,this.tempVector3_3=new w,this.tempVector3_P0=new w,this.tempVector3_P1=new w,this.tempVector3_P2=new w,this.tempVector3_N0=new w,this.tempVector3_N1=new w,this.tempVector3_AB=new w,this.tempVector3_CB=new w,this.tempResultObjects={object1:null,object2:null},this.segments=[];const n=30*30;for(let o=0;o<n;o++)this.segments[o]=!1}prepareBreakableObject(e,t,n,o,s){const i=e.userData;i.mass=t,i.velocity=n.clone(),i.angularVelocity=o.clone(),i.breakable=s}subdivideByImpact(e,t,n,o,s){const i=[],a=this.tempPlane1,l=this.tempPlane2;this.tempVector3.addVectors(t,n),a.setFromCoplanarPoints(t,e.position,this.tempVector3);const c=s+o,h=this;function f(r,p,d,g){if(Math.random()<g*.05||g>c){i.push(r);return}let v=Math.PI;g===0?(l.normal.copy(a.normal),l.constant=a.constant):g<=o?(v=(d-p)*(.2+.6*Math.random())+p,h.tempVector3_2.copy(e.position).sub(t).applyAxisAngle(n,v).add(t),l.setFromCoplanarPoints(t,h.tempVector3,h.tempVector3_2)):(v=(.5*(g&1)+.2*(2-Math.random()))*Math.PI,h.tempVector3_2.copy(t).sub(r.position).applyAxisAngle(n,v).add(r.position),h.tempVector3_3.copy(n).add(r.position),l.setFromCoplanarPoints(r.position,h.tempVector3_3,h.tempVector3_2)),h.cutByPlane(r,l,h.tempResultObjects);const M=h.tempResultObjects.object1,y=h.tempResultObjects.object2;M&&f(M,p,v,g+1),y&&f(y,v,d,g+1)}return f(e,0,2*Math.PI,0),i}cutByPlane(e,t,n){const o=e.geometry,s=o.attributes.position.array,i=o.attributes.normal.array,a=s.length/3;let l=a/3,c=o.getIndex();c&&(c=c.array,l=c.length/3);function h(m,x){const P=m*3+x;return c?c[P]:P}const f=[],r=[],p=this.smallDelta,d=a*a;for(let m=0;m<d;m++)this.segments[m]=!1;const g=this.tempVector3_P0,v=this.tempVector3_P1,M=this.tempVector3_N0,y=this.tempVector3_N1;for(let m=0;m<l-1;m++){const x=h(m,0),P=h(m,1),T=h(m,2);M.set(i[x],i[x]+1,i[x]+2);for(let _=m+1;_<l;_++){const V=h(_,0),k=h(_,1),K=h(_,2);y.set(i[V],i[V]+1,i[V]+2),1-M.dot(y)<p&&(x===V||x===k||x===K?P===V||P===k||P===K?(this.segments[x*a+P]=!0,this.segments[P*a+x]=!0):(this.segments[T*a+x]=!0,this.segments[x*a+T]=!0):(P===V||P===k||P===K)&&(this.segments[T*a+P]=!0,this.segments[P*a+T]=!0))}}const u=this.tempPlane_Cut;e.updateMatrix(),J.transformPlaneToLocalSpace(t,e.matrix,u);for(let m=0;m<l;m++){const x=h(m,0),P=h(m,1),T=h(m,2);for(let _=0;_<3;_++){const V=_===0?x:_===1?P:T,k=_===0?P:_===1?T:x;if(this.segments[V*a+k])continue;this.segments[V*a+k]=!0,this.segments[k*a+V]=!0,g.set(s[3*V],s[3*V+1],s[3*V+2]),v.set(s[3*k],s[3*k+1],s[3*k+2]);let N=0,q=u.distanceToPoint(g);q>p?(N=2,r.push(g.clone())):q<-p?(N=1,f.push(g.clone())):(N=3,f.push(g.clone()),r.push(g.clone()));let G=0;if(q=u.distanceToPoint(v),q>p?(G=2,r.push(v.clone())):q<-p?(G=1,f.push(v.clone())):(G=3,f.push(v.clone()),r.push(v.clone())),N===1&&G===2||N===2&&G===1){this.tempLine1.start.copy(g),this.tempLine1.end.copy(v);let W=new w;if(W=u.intersectLine(this.tempLine1,W),W===null)return console.error("Internal error: segment does not intersect plane."),n.segmentedObject1=null,n.segmentedObject2=null,0;f.push(W),r.push(W.clone())}}}const F=e.userData.mass*.5;this.tempCM1.set(0,0,0);let C=0;const b=f.length;if(b>0){for(let m=0;m<b;m++)this.tempCM1.add(f[m]);this.tempCM1.divideScalar(b);for(let m=0;m<b;m++){const x=f[m];x.sub(this.tempCM1),C=Math.max(C,x.x,x.y,x.z)}this.tempCM1.add(e.position)}this.tempCM2.set(0,0,0);let A=0;const E=r.length;if(E>0){for(let m=0;m<E;m++)this.tempCM2.add(r[m]);this.tempCM2.divideScalar(E);for(let m=0;m<E;m++){const x=r[m];x.sub(this.tempCM2),A=Math.max(A,x.x,x.y,x.z)}this.tempCM2.add(e.position)}let B=null,z=null,L=0;return b>4&&(B=new se(new fe(f),e.material),B.position.copy(this.tempCM1),B.quaternion.copy(e.quaternion),this.prepareBreakableObject(B,F,e.userData.velocity,e.userData.angularVelocity,2*C>this.minSizeForBreak),L++),E>4&&(z=new se(new fe(r),e.material),z.position.copy(this.tempCM2),z.quaternion.copy(e.quaternion),this.prepareBreakableObject(z,F,e.userData.velocity,e.userData.angularVelocity,2*A>this.minSizeForBreak),L++),n.object1=B,n.object2=z,L}static transformFreeVector(e,t){const n=e.x,o=e.y,s=e.z,i=t.elements;return e.x=i[0]*n+i[4]*o+i[8]*s,e.y=i[1]*n+i[5]*o+i[9]*s,e.z=i[2]*n+i[6]*o+i[10]*s,e}static transformFreeVectorInverse(e,t){const n=e.x,o=e.y,s=e.z,i=t.elements;return e.x=i[0]*n+i[1]*o+i[2]*s,e.y=i[4]*n+i[5]*o+i[6]*s,e.z=i[8]*n+i[9]*o+i[10]*s,e}static transformTiedVectorInverse(e,t){const n=e.x,o=e.y,s=e.z,i=t.elements;return e.x=i[0]*n+i[1]*o+i[2]*s-i[12],e.y=i[4]*n+i[5]*o+i[6]*s-i[13],e.z=i[8]*n+i[9]*o+i[10]*s-i[14],e}static transformPlaneToLocalSpace(e,t,n){n.normal.copy(e.normal),n.constant=e.constant;const o=J.transformTiedVectorInverse(e.coplanarPoint(at),t);J.transformFreeVectorInverse(n.normal,t),n.constant=-o.dot(n.normal)}}function ve(S,e){oe(e,!0);let t=O(e,"shape",3,"convexHull"),n=O(e,"colliders",15);const o=new De,{updateRef:s}=Ne(e.oncreate),i=Oe(),a=qe(),{world:l,addColliderToContext:c,removeColliderFromContext:h}=Ge(),f=We(),r=()=>{n()!==void 0&&(f.removeColliders(n()),n().forEach(u=>{h(u),l.removeCollider(u,!0)}),n(n().length=0,!0))},p={oncollisionenter:e.oncollisionenter,oncollisionexit:e.oncollisionexit,oncontact:e.oncontact,onsensorenter:e.onsensorenter,onsensorexit:e.onsensorexit},d=()=>{r(),n(Qe(o,t()??"convexHull",l,i,a)),n().forEach(u=>c(u,o,p)),f.registerColliders(n()),n().forEach(u=>{var F;Ue(u,p,(F=i==null?void 0:i.userData)==null?void 0:F.events),u.setActiveCollisionTypes(Ye.ALL),u.setRestitution(e.restitution??0),u.setRestitutionCombineRule(e.restitutionCombineRule??he.Average),u.setFriction(e.friction??.7),u.setFrictionCombineRule(e.frictionCombineRule??he.Average),u.setSensor(e.sensor??!1),u.setContactForceEventThreshold(e.contactForceEventThreshold??0),e.density&&u.setDensity(e.density),e.mass&&(e.centerOfMass&&e.principalAngularInertia&&e.angularInertiaLocalFrame?u.setMassProperties(e.mass,{x:e.centerOfMass[0],y:e.centerOfMass[1],z:e.centerOfMass[2]},{x:e.principalAngularInertia[0],y:e.principalAngularInertia[1],z:e.principalAngularInertia[2]},Je(e.angularInertiaLocalFrame)):u.setMass(e.mass))}),s(n())},g=()=>d();Xe(()=>{d()}),Ze(r);const v=ze();Le(o),Re(v,u=>(u==null||u.add(o),()=>{u==null||u.remove(o)}));var M=Y(),y=I(M);return Ke(y,()=>e.children??Pe,()=>({colliders:n()??[],refresh:g})),R(S,M),re({refresh:g})}const pe=new J;function ye(S,e){oe(e,!0);let t=O(e,"fixed",3,!1),n=O(e,"depth",3,0),o=O(e,"maxDepth",3,1),s=O(e,"minBreakForce",3,100),i=_e(e,["$$slots","$$events","$$legacy","fixed","depth","maxDepth","minBreakForce","mesh"]),a=Fe(ne([]));n()===0&&pe.prepareBreakableObject(e.mesh,1,new w,new w,!0);let l,c;const h=y=>{if(n()>=o()||y.manifold.numContacts()===0)return;const F=y.manifold.localContactPoint1(0);F&&(l=new w(F.x,F.y,F.z))},f=new w,r=new Se;new w;const p=y=>{if(!l)return;if(y.totalForceMagnitude<s()){l=void 0;return}const u=y.maxForceDirection;c=new w(u.x,u.y,u.z),Me(a,ne(pe.subdivideByImpact(e.mesh,l,c,2,1)));const F=e.mesh.parent;F.getWorldPosition(f),F.getWorldQuaternion(r);for(const C of j(a))C.quaternion.copy(r),C.position.add(f),C.castShadow=C.receiveShadow=!0};var d=Y(),g=I(d);{var v=y=>{var u=ae(()=>t()?"fixed":"dynamic");we(y,Ve({get type(){return j(u)},oncollisionenter:h,oncontact:p,canSleep:!1},()=>i,{children:(F,C)=>{ve(F,{shape:"convexHull",children:(b,A)=>{H(b,{get is(){return e.mesh}})},$$slots:{default:!0}})},$$slots:{default:!0}}))},M=y=>{var u=Y(),F=I(u);ge(F,17,()=>j(a),C=>C.uuid,(C,b)=>{var A=Y(),E=I(A);U(E,()=>H.Group,(B,z)=>{z(B,{scale:.98,children:(L,m)=>{var x=ae(()=>n()+1);ye(L,{get mesh(){return j(b)},get depth(){return j(x)},get maxDepth(){return o()},get minBreakForce(){return s()}})},$$slots:{default:!0}})}),R(C,A)}),R(y,u)};$e(g,y=>{j(a).length===0?y(v):y(M,!1)})}R(S,d),re()}var lt=ie("<!> <!>",1),ct=ie("<!> <!>",1),ht=ie("<!> <!> <!> <!>",1);function ut(S,e){oe(e,!0);const{scene:t}=Ie(),{frequencyData:n}=tt(),o=()=>{const r=new Ae;r.roughness=.1;const p=new Ee,d=new se(p,r);return d.castShadow=d.receiveShadow=!0,d.position.y=3,d};let s=ne([o()]);le(()=>{const r=setInterval(()=>s.push(o()),2e4);return()=>clearInterval(r)}),le(()=>(t.fog=new Be("#000",2,10),()=>t.fog=null));const i=new ke;je(r=>{const p=n.current[16]/200;i.intensity=Math.min(1,Math.max(nt(p,0,2*r),.5))});var a=ht(),l=I(a);U(l,()=>H.PerspectiveCamera,(r,p)=>{p(r,{makeDefault:!0,"position.y":1,"position.z":5,oncreate:d=>d.lookAt(0,0,0)})});var c=Q(l,2);H(c,{is:i,intensity:.5,position:[1,1,1],castShadow:!0});var h=Q(c,2);He(h,{gravity:[0,-1,0],children:(r,p)=>{var d=ct(),g=I(d);ge(g,17,()=>s,Ce,(M,y)=>{ye(M,{get mesh(){return j(y)},minBreakForce:.1,maxDepth:2})});var v=Q(g,2);we(v,{type:"fixed",children:(M,y)=>{ve(M,{shape:"cuboid",children:(u,F)=>{var C=Y(),b=I(C);U(b,()=>H.Mesh,(A,E)=>{E(A,{"position.y":-1,receiveShadow:!0,children:(B,z)=>{var L=lt(),m=I(L);U(m,()=>H.BoxGeometry,(P,T)=>{T(P,{args:[20,.1,20]})});var x=Q(m,2);U(x,()=>H.MeshStandardMaterial,(P,T)=>{T(P,{roughness:.1})}),R(B,L)},$$slots:{default:!0}})}),R(u,C)},$$slots:{default:!0}})},$$slots:{default:!0}}),R(r,d)},$$slots:{default:!0}});var f=Q(h,2);et(f,{}),R(S,a),re()}const bt=Object.freeze(Object.defineProperty({__proto__:null,default:ut},Symbol.toStringTag,{value:"Module"}));export{ut as _,bt as a};
