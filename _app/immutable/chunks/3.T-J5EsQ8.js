import"./disclose-version.Bg9kRutz.js";import"./legacy.CtaTdtmd.js";import{b as nt,a as x,t as Q,c as N}from"./template.BCsPwpPZ.js";import{i as ot,G as lt,M as ct,u as dt,d as j,a5 as ft,a3 as ut,s as Ie,V as vt,D as Te}from"./T.D7KAkooU.js";import{d as mt,i as ht,a as gt,o as pt,g as yt,e as Fe,b as _t,c as xt,f as bt}from"./index.Byt2NWqd.js";import{v as wt,E as Mt,C as Pt,w as R,x as We,F as ge,D as St,B as zt,V as Ct,W as Rt,G as Et,A as je,z as Ae,M as It,aS as Tt,n as Ft,h as Wt,p as jt,u as Ve,d as At,f as E,a as Vt,k as t,m as I,s as Oe,t as pe,a5 as He,c as ae,a2 as ke,r as se,a6 as Ne}from"./index-client.7bxKioEb.js";import{i as K}from"./if.J9R6XJFY.js";import{c as ye}from"./svelte-component.C-0_6v47.js";import{e as Ot,f as Ge}from"./render.DpKYLZQ6.js";import{b as Ze,c as Be,s as De}from"./class.D9OKVRHN.js";import{b as _e}from"./this.CEjktYH2.js";import{b as Ht,p as y,s as kt,r as Nt,c as Le}from"./props.gynuqLyB.js";function Gt(r,e,m,d,T,xe){let G=R;R&&We();var A,P,h=null;R&&ge.nodeType===1&&(h=ge,We());var g=R?ge:r,l;wt(()=>{const f=e()||null;var Z=f==="svg"?Tt:null;f!==A&&(l&&(f===null?St(l,()=>{l=null,P=null}):f===P?zt(l):(Ct(l),Ge(!1))),f&&f!==P&&(l=Pt(()=>{if(h=R?h:Z?document.createElementNS(Z,f):document.createElement(f),nt(h,h),d){R&&Ot(f)&&h.append(document.createComment(""));var V=R?Rt(h):h.appendChild(Et());R&&(V===null?je(!1):Ae(V)),d(h,V)}It.nodes_end=h,g.before(h)})),A=f,A&&(P=A),Ge(!0))},Mt),G&&(je(!0),Ae(g))}function Zt(r,e,m){Ft(()=>{var d=Wt(()=>e(r,m==null?void 0:m())||{});if(d!=null&&d.destroy)return()=>d.destroy()})}function n(r,e,m,d){var T=r.__styles??(r.__styles={});T[e]!==m&&(T[e]=m,m==null?r.style.removeProperty(e):r.style.setProperty(e,m,""))}const Bt=`
#include <common>
#include <logdepthbuf_pars_vertex>
void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    #include <logdepthbuf_vertex>
}`,qe=`
#include <logdepthbuf_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4(0.0,0.0,0.0,0.0);
}`,Dt=`
#include <common>
#include <logdepthbuf_pars_vertex>

void main() {
  vec2 center = vec2(0., 1.);
  float rotation = 0.0;
  
  // This is somewhat arbitrary, but it seems to work well
  // Need to figure out how to derive this dynamically if it even matters
  float size = 0.03;

  vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
  vec2 scale = vec2(
    length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) ),
    length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) )
  );

  bool isPerspective = isPerspectiveMatrix( projectionMatrix );
  if ( isPerspective ) scale *= - mvPosition.z;

  vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
  vec2 rotatedPosition;
  rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
  rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
  mvPosition.xy += rotatedPosition;

  gl_Position = projectionMatrix * mvPosition;
  #include <logdepthbuf_vertex>
}`;let re=!1,ie=0,Je="",Ke="",Qe="";const Ue=(r,e)=>{ie===1&&!re?(Je=r.style.zIndex,Ke=r.style.position,Qe=r.style.pointerEvents,r.style.zIndex=`${Math.floor(e/2)}`,r.style.position="absolute",r.style.pointerEvents="none",re=!0):ie===0&&re&&(r.style.zIndex=Je,r.style.position=Ke,r.style.pointerEvents=Qe,re=!1)};var Lt=Q("<!> <!>",1),qt=Q("<div><div><div><!></div></div></div>"),Jt=Q("<div><!></div>"),Kt=Q("<!> <!>",1);function Qt(r,e){jt(e,!0);const m=Ht(),d=()=>Le(Ye,"$size",m),T=()=>Le(v,"$camera",m);let xe=y(e,"autoRender",3,!0),G=y(e,"eps",3,.001),A=y(e,"center",3,!1),P=y(e,"fullscreen",3,!1),h=y(e,"sprite",3,!1),g=y(e,"transform",3,!1),l=y(e,"occlude",3,!1),f=y(e,"zIndexRange",19,()=>[16777271,0]),Z=y(e,"calculatePosition",3,mt),V=y(e,"as",3,"div"),Xe=y(e,"pointerEvents",3,"auto"),be=y(e,"ref",15),F=y(e,"visible",15),we=Nt(e,["$$slots","$$events","$$legacy","autoRender","eps","center","fullscreen","portal","distanceFactor","sprite","transform","occlude","castShadow","receiveShadow","material","geometry","zIndexRange","calculatePosition","as","wrapperClass","pointerEvents","ref","visible","style","children"]);F(!0);const{camera:v,scene:Me,size:Ye,dom:$e,canvas:Pe}=ot(),b=new lt;let w=document.createElement(V()),Se=0,U=[0,0],O=He(void 0),X=He(void 0),ne=!1;const H=new ct,et=new ft;let Y=I(()=>l()&&l()!=="blending"||Array.isArray(l())&&l().length>0),C=new ut,B=I(()=>d().width),D=I(()=>d().height),tt=I(()=>t(B)/2),ze=I(()=>t(D)/2),oe=I(()=>T().projectionMatrix.elements[5]*t(ze)),at=I(()=>bt(T(),new vt,d()));Ve(()=>{e.wrapperClass&&(w.className=e.wrapperClass)}),Ve(()=>(l()==="blending"&&(ie+=1,Ue(Pe,f()[0])),()=>{ie-=1,Ue(Pe,f()[0])}));const $=()=>{v.current.updateMatrixWorld(),b.updateWorldMatrix(!0,!1);const i=g()?U:Z()(b,v.current,d());if(g()||Math.abs(Se-v.current.zoom)>G()||Math.abs(U[0]-i[0])>G()||Math.abs(U[1]-i[1])>G()){const a=ht(b,v.current);let u=!1;t(Y)&&(Array.isArray(l())?u=l():l()!=="blending"&&(u=[Me]));const c=F();if(u){const o=gt(b,v.current,et,u);F(o&&!a)}else F(!a);c!==F()&&(e.onvisibilitychange?e.onvisibilitychange(F()):w.style.display=F()?"block":"none");const M=Math.floor(f()[0]/2),S=l()?t(Y)?[f()[0],M]:[M-1,0]:f();if(w.style.zIndex=`${pt(b,v.current,S)}`,g()&&t(O)&&t(X)){const{isOrthographicCamera:o,top:s,left:_,bottom:z,right:L}=v.current,W=yt(v.current.matrixWorldInverse),ce=o?`scale(${t(oe)})translate(${Fe(-(L+_)/2)}px,${Fe((s+z)/2)}px)`:`translateZ(${t(oe)}px)`;h()?(C.copy(v.current.matrixWorldInverse).transpose().copyPosition(C).scale(b.scale),C.elements[3]=C.elements[7]=C.elements[11]=0,C.elements[15]=1):C.copy(b.matrixWorld),w.style.width=`${t(B)}px`,w.style.height=`${t(D)}px`,w.style.perspective=o?"":`${t(oe)}px`,t(O).style.transform=`${ce}${W}translate(${t(tt)}px,${t(ze)}px)`,t(X).style.transform=_t(C,1/((e.distanceFactor||10)/400))}else{const o=e.distanceFactor===void 0?1:xt(b,v.current)*e.distanceFactor;w.style.transform=`translate3d(${i[0]}px,${i[1]}px,0) scale(${o})`}U=i,Se=v.current.zoom}if(!t(Y)&&!ne)if(g()&&t(O)){const a=t(O).children[0];if(a!=null&&a.clientWidth&&(a!=null&&a.clientHeight)){const{isOrthographicCamera:u}=v.current;if(u||e.geometry){const{scale:c}=we;c&&(Array.isArray(c)?H.scale.set(1/c[0],1/c[1],1/c[2]):H.scale.setScalar(1/c))}else{const c=(e.distanceFactor??10)/400,M=a.clientWidth*c,S=a.clientHeight*c;H.scale.set(M,S,1)}ne=!0}}else{const a=w.children[0];if(a!=null&&a.clientWidth&&(a!=null&&a.clientHeight)){const u=1/t(at),c=a.clientWidth*u,M=a.clientHeight*u;H.scale.set(c,M,1),ne=!0}H.lookAt(v.current.position)}},{start:ee,stop:te}=dt($,{autoStart:!1});At(()=>{if(xe())return ee(),()=>{te()}});let Ce=I(()=>(Me.updateMatrixWorld(),Z()(b,T(),d())));const le=i=>{const a=e.portal??$e;if(!a){console.warn("<HTML>: target is undefined.");return}return a.append(i),{destroy:()=>i.remove()}};var Re=Kt(),Ee=E(Re);j(Ee,kt({is:b},()=>we,{get ref(){return be()},set ref(i){be(i)},children:(i,a)=>{var u=N(),c=E(u);{var M=S=>{j(S,{is:H,get castShadow(){return e.castShadow},get receiveShadow(){return e.receiveShadow},children:(o,s)=>{var _=Lt(),z=E(_);{var L=p=>{j(p,{get is(){return e.geometry}})},W=p=>{var q=N(),de=E(q);ye(de,()=>j.PlaneGeometry,(fe,ue)=>{ue(fe,{})}),x(p,q)};K(z,p=>{e.geometry?p(L):p(W,!1)})}var ce=Oe(z,2);{var rt=p=>{j(p,{get is(){return e.material}})},it=p=>{var q=N(),de=E(q);{var fe=k=>{var J=N(),ve=E(J);ye(ve,()=>j.ShaderMaterial,(me,he)=>{he(me,{side:Te,vertexShader:Dt,fragmentShader:qe})}),x(k,J)},ue=k=>{var J=N(),ve=E(J);ye(ve,()=>j.ShaderMaterial,(me,he)=>{he(me,{side:Te,vertexShader:Bt,fragmentShader:qe})}),x(k,J)};K(de,k=>{g()?k(ue,!1):k(fe)},!0)}x(p,q)};K(ce,p=>{e.material?p(rt):p(it,!1)})}x(o,_)},$$slots:{default:!0}})};K(c,S=>{l()&&!t(Y)&&S(M)})}x(i,u)},$$slots:{default:!0}}));var st=Oe(Ee,2);return Gt(st,V,!1,(i,a)=>{Zt(i,o=>le==null?void 0:le(o)),_e(i,o=>w=o,()=>w),n(i,"position","absolute"),n(i,"top","0"),n(i,"left","0"),pe(()=>{n(i,"pointer-events",g()?"none":void 0),n(i,"overflow",g()?"hidden":void 0),n(i,"transform",g()?void 0:`translate3d(${t(Ce)[0]}px,${t(Ce)[1]}px,0)`),n(i,"transform-origin",g()?void 0:"0 0")});var u=N(),c=E(u);{var M=o=>{var s=qt();n(s,"position","absolute"),n(s,"top","0"),n(s,"left","0"),n(s,"transform-style","preserve-3d"),n(s,"pointer-events","none");var _=ae(s);n(_,"position","absolute");var z=ae(_),L=ae(z);Ie(L,()=>e.children??ke,()=>({render:$,startRendering:ee,stopRendering:te})),se(z),se(_),_e(_,W=>Ne(X,W),()=>t(X)),se(s),_e(s,W=>Ne(O,W),()=>t(O)),pe(()=>{n(s,"width",`${t(B)}px`),n(s,"height",`${t(D)}px`),n(_,"pointer-events",Xe()),Ze(z,Be(e.class),""),De(z,"style",e.style)}),x(o,s)},S=o=>{var s=Jt(),_=ae(s);Ie(_,()=>e.children??ke,()=>({render:$,startRendering:ee,stopRendering:te})),se(s),pe(()=>{De(s,"style",e.style),Ze(s,Be(e.class),""),n(s,"position","absolute"),n(s,"transform",A()?"translate3d(-50%,-50%,0)":"none"),n(s,"top",P()?`${-t(D)/2}px`:void 0),n(s,"left",P()?`${-t(B)/2}px`:void 0),n(s,"width",P()?`${t(B)/2}px`:void 0),n(s,"height",P()?`${t(D)}px`:void 0)}),x(o,s)};K(c,o=>{g()?o(M):o(S,!1)})}x(a,u)}),x(r,Re),Vt({render:$,startRendering:ee,stopRendering:te})}var Ut=Q(`<div class="absolute left-0 top-0 grid place-content-center"><div class="w-[200px] text-white">zesty.plus is a music visualizer, inspired by what iTunes did back in the
			days of yore. How it functions is simple: it analyzes incoming microphone
			data and produces fun doodles from it. It also has optional music service
			and camera integration features, but that stuff isn't required if you want
			a pure, organic experience.</div></div>`);function Xt(r){Qt(r,{center:!0,autoRender:!0,children:(e,m)=>{var d=Ut();x(e,d)},$$slots:{default:!0}})}const da=Object.freeze(Object.defineProperty({__proto__:null,default:Xt},Symbol.toStringTag,{value:"Module"}));export{Xt as _,da as a};
