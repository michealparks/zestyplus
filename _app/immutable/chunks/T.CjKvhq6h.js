var re=Object.defineProperty;var se=(t,e,r)=>e in t?re(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r;var g=(t,e,r)=>se(t,typeof e!="symbol"?e+"":e,r);import{a7 as ne,a8 as ae,a9 as oe,aa as O,ab as _,ac as ie,ad as ce}from"./three.module.iKKkBh6O.js";import{c as ue,b as de}from"./disclose-version.n6tle2S8.js";import{ab as le,aL as H,T as p,N as fe,g as U,ac as Q,a6 as he,Q as x,u as M,W as q,F as y,G as V,B as me,a8 as ge,D as pe,n as be}from"./runtime.D2gsQGmM.js";import{s as xe}from"./snippet.ZcDO5fuy.js";import{p as D,r as ve}from"./props.TOh5px3p.js";import{a as R,o as X}from"./index-client.CGW19OF7.js";import{g as K,d as N,w as S,r as J}from"./index.B1FXc25O.js";function ye(t){le(t,t.v+1)}function we(t){let e=0,r=he(0),s;return()=>{H()&&(p(r),fe(()=>(e===0&&(s=U(()=>t(()=>ye(r)))),e+=1,()=>{Q().then(()=>{e-=1,e===0&&(s==null||s(),s=void 0)})})))}}function Se(t){let e;const r=we(n=>{let a=!1;const i=t.subscribe(o=>{e=o,a&&n()});return a=!0,i});function s(){return H()?(r(),e):K(t)}return"set"in t?{get current(){return s()},set current(n){t.set(n)}}:{get current(){return s()}}}const B=Symbol(),Ve=t=>typeof(t==null?void 0:t.subscribe)=="function",Y=(t,e,r)=>{const s=t().map(i=>Ve(i)?Se(i):B),n=q(()=>t().map((i,o)=>s[o]===B?i:s[o].current)),a=()=>{p(n);let i;return U(()=>{i=e(p(n))}),i};r?x(a):M(a)},Ce=(t,e)=>Y(t,e,!1),Me=(t,e)=>Y(t,e,!0),ht=Object.assign(Ce,{pre:Me}),v=(t,e)=>(t==null?void 0:t[`is${e}`])===!0,Re=typeof window<"u",b=(t,e)=>{const r=N(t,a=>a);let s;const n=r.subscribe(async a=>{s&&s();const i=await e(a);i&&(s=i)});R(()=>{n(),s&&s()})},w=t=>{const e=S(t),r={set:s=>{r.current=s,e.set(s)},subscribe:e.subscribe,update:s=>{const n=s(r.current);r.current=n,e.set(n)},current:t};return r},ke=t=>({subscribe:t.subscribe,get current(){return t.current}}),Z=(t,e)=>{if(e.includes(".")){const r=e.split("."),s=r.pop();for(let n=0;n<r.length;n+=1)t=t[r[n]];return{target:t,key:s}}else return{target:t,key:e}},mt=t=>{const e=t.dom.getBoundingClientRect();let r=e.width,s=e.height;const n=w(e);X(()=>{const i=new ResizeObserver(o=>{for(const d of o){const{width:c,height:l}=d.contentRect;if(c===r&&l===s)return;r=c,s=l,n.set(d.contentRect)}});return i.observe(t.dom),()=>{i.disconnect()}});const a={dom:t.dom,canvas:t.canvas,size:ke(n)};return V("threlte-dom-context",a),a},j=()=>{const t=y("threlte-dom-context");if(!t)throw new Error("useDOM can only be used in a child component to <Canvas>.");return t};function Te(t){return{all:t=t||new Map,on:function(e,r){var s=t.get(e);s?s.push(r):t.set(e,[r])},off:function(e,r){var s=t.get(e);s&&(r?s.splice(s.indexOf(r)>>>0,1):t.set(e,[]))},emit:function(e,r){var s=t.get(e);s&&s.slice().map(function(n){n(r)}),(s=t.get("*"))&&s.slice().map(function(n){n(e,r)})}}}class C{constructor(){g(this,"allVertices",{});g(this,"isolatedVertices",{});g(this,"connectedVertices",{});g(this,"sortedConnectedValues",[]);g(this,"needsSort",!1);g(this,"emitter",Te());g(this,"emit",this.emitter.emit.bind(this.emitter));g(this,"on",this.emitter.on.bind(this.emitter));g(this,"off",this.emitter.off.bind(this.emitter));g(this,"getKey",e=>typeof e=="object"?e.key:e)}get sortedVertices(){return this.mapNodes(e=>e)}moveToIsolated(e){const r=this.connectedVertices[e];r&&(this.isolatedVertices[e]=r,delete this.connectedVertices[e])}moveToConnected(e){const r=this.isolatedVertices[e];r&&(this.connectedVertices[e]=r,delete this.isolatedVertices[e])}add(e,r,s){if(this.allVertices[e]&&this.allVertices[e].value!==void 0)throw new Error(`A node with the key ${e.toString()} already exists`);let n=this.allVertices[e];n?n.value===void 0&&(n.value=r):(n={value:r,previous:new Set,next:new Set},this.allVertices[e]=n);const a=n.next.size>0||n.previous.size>0;if(!(s!=null&&s.after)&&!(s!=null&&s.before)&&!a){this.isolatedVertices[e]=n,this.emit("node:added",{key:e,type:"isolated",value:r});return}else this.connectedVertices[e]=n;if(s!=null&&s.after){const i=Array.isArray(s.after)?s.after:[s.after];i.forEach(o=>{n.previous.add(this.getKey(o))}),i.forEach(o=>{const d=this.getKey(o),c=this.allVertices[d];c?(c.next.add(e),this.moveToConnected(d)):(this.allVertices[d]={value:void 0,previous:new Set,next:new Set([e])},this.connectedVertices[d]=this.allVertices[d])})}if(s!=null&&s.before){const i=Array.isArray(s.before)?s.before:[s.before];i.forEach(o=>{n.next.add(this.getKey(o))}),i.forEach(o=>{const d=this.getKey(o),c=this.allVertices[d];c?(c.previous.add(e),this.moveToConnected(d)):(this.allVertices[d]={value:void 0,previous:new Set([e]),next:new Set},this.connectedVertices[d]=this.allVertices[d])})}this.emit("node:added",{key:e,type:"connected",value:r}),this.needsSort=!0}remove(e){const r=this.getKey(e);if(this.isolatedVertices[r]){delete this.isolatedVertices[r],delete this.allVertices[r],this.emit("node:removed",{key:r,type:"isolated"});return}const n=this.connectedVertices[r];n&&(n.next.forEach(a=>{const i=this.connectedVertices[a];i&&(i.previous.delete(r),i.previous.size===0&&i.next.size===0&&this.moveToIsolated(a))}),n.previous.forEach(a=>{const i=this.connectedVertices[a];i&&(i.next.delete(r),i.previous.size===0&&i.next.size===0&&this.moveToIsolated(a))}),delete this.connectedVertices[r],delete this.allVertices[r],this.emit("node:removed",{key:r,type:"connected"}),this.needsSort=!0)}mapNodes(e){this.needsSort&&this.sort();const r=[];return this.forEachNode((s,n)=>{r.push(e(s,n))}),r}forEachNode(e){this.needsSort&&this.sort();let r=0;for(;r<this.sortedConnectedValues.length;r++)e(this.sortedConnectedValues[r],r);Reflect.ownKeys(this.isolatedVertices).forEach(s=>{const n=this.isolatedVertices[s];n.value!==void 0&&e(n.value,r++)})}getValueByKey(e){var r;return(r=this.allVertices[e])==null?void 0:r.value}getKeyByValue(e){return Reflect.ownKeys(this.connectedVertices).find(r=>this.connectedVertices[r].value===e)??Reflect.ownKeys(this.isolatedVertices).find(r=>this.isolatedVertices[r].value===e)}sort(){var i;const e=new Map,r=[],s=[],n=Reflect.ownKeys(this.connectedVertices).filter(o=>this.connectedVertices[o].value!==void 0);for(n.forEach(o=>{e.set(o,0)}),n.forEach(o=>{this.connectedVertices[o].next.forEach(c=>{this.connectedVertices[c]&&e.set(c,(e.get(c)||0)+1)})}),e.forEach((o,d)=>{o===0&&r.push(d)});r.length>0;){const o=r.shift();s.push(o);const d=n.find(c=>c===o);d&&((i=this.connectedVertices[d])==null||i.next.forEach(c=>{const l=(e.get(c)||0)-1;e.set(c,l),l===0&&r.push(c)}))}if(s.length!==n.length)throw new Error("The graph contains a cycle, and thus can not be sorted topologically.");const a=o=>o!==void 0;this.sortedConnectedValues=s.map(o=>this.connectedVertices[o].value).filter(a),this.needsSort=!1}clear(){this.allVertices={},this.isolatedVertices={},this.connectedVertices={},this.sortedConnectedValues=[],this.needsSort=!1}static isKey(e){return typeof e=="string"||typeof e=="symbol"}static isValue(e){return typeof e=="object"&&"key"in e}}class Ee{constructor(e,r,s){g(this,"key");g(this,"stage");g(this,"callback");g(this,"runTask",!0);this.stage=e,this.key=r,this.callback=s}stop(){this.runTask=!1}start(){this.runTask=!0}run(e){this.runTask&&this.callback(e)}}class De extends C{constructor(r,s,n){super();g(this,"key");g(this,"scheduler");g(this,"runTask",!0);g(this,"callback",(r,s)=>s());g(this,"removeTask",this.remove.bind(this));this.scheduler=r,this.key=s,this.start=this.start.bind(this),this.stop=this.stop.bind(this),n&&(this.callback=n.bind(this))}stop(){this.runTask=!1}start(){this.runTask=!0}get tasks(){return this.sortedVertices}createTask(r,s,n){const a=new Ee(this,r,s);return this.add(r,a,n),a}getTask(r){return this.getValueByKey(r)}run(r){this.runTask&&this.callback(r,s=>{this.forEachNode(n=>{n.run(s??r)})})}runWithTiming(r){if(!this.runTask)return{};const s={};return this.callback(r,n=>{this.forEachNode(a=>{const i=performance.now();a.run(n??r);const o=performance.now()-i;s[a.key]=o})}),s}getSchedule(){return this.mapNodes(r=>r.key.toString())}}class Pe extends C{constructor(r){super();g(this,"lastTime",performance.now());g(this,"clampDeltaTo",.1);g(this,"removeStage",this.remove.bind(this));r!=null&&r.clampDeltaTo&&(this.clampDeltaTo=r.clampDeltaTo),this.run=this.run.bind(this)}get stages(){return this.sortedVertices}createStage(r,s){const n=new De(this,r,s==null?void 0:s.callback);return this.add(r,n,{after:s==null?void 0:s.after,before:s==null?void 0:s.before}),n}getStage(r){return this.getValueByKey(r)}run(r){const s=r-this.lastTime;this.forEachNode(n=>{n.run(Math.min(s/1e3,this.clampDeltaTo))}),this.lastTime=r}runWithTiming(r){const s=r-this.lastTime,n={},a=performance.now();return this.forEachNode(i=>{const o=performance.now(),d=i.runWithTiming(Math.min(s/1e3,this.clampDeltaTo)),c=performance.now()-o;n[i.key.toString()]={duration:c,tasks:d}}),{total:performance.now()-a,stages:n}}getSchedule(r={tasks:!0}){return{stages:this.mapNodes(s=>{if(s===void 0)throw new Error("Stage not found");return{key:s.key.toString(),tasks:r.tasks?s.getSchedule():void 0}})}}dispose(){this.clear()}}const gt=t=>{const e=new Pe,r=e.createStage(Symbol("threlte-main-stage")),s={scheduler:e,frameInvalidated:!0,autoInvalidations:new Set,shouldAdvance:!1,advance:()=>{s.shouldAdvance=!0},autoRender:w(t.autoRender??!0),renderMode:w(t.renderMode??"on-demand"),invalidate(){s.frameInvalidated=!0},mainStage:r,shouldRender:()=>s.renderMode.current==="always"||s.renderMode.current==="on-demand"&&(s.frameInvalidated||s.autoInvalidations.size>0)||s.renderMode.current==="manual"&&s.shouldAdvance,renderStage:e.createStage(Symbol("threlte-render-stage"),{after:r,callback(n,a){s.shouldRender()&&a()}}),resetFrameInvalidation(){s.frameInvalidated=!1,s.shouldAdvance=!1}};return M(()=>{s.autoRender.set(t.autoRender??!0)}),M(()=>{s.renderMode.set(t.renderMode??"on-demand")}),R(()=>{s.scheduler.dispose()}),V("threlte-scheduler-context",s),s},A=()=>{const t=y("threlte-scheduler-context");if(!t)throw new Error("useScheduler can only be used in a child component to <Canvas>.");return t},pt=()=>{const{size:t}=j(),{invalidate:e}=A(),r=new ne(75,0,.1,1e3);r.position.z=5,r.lookAt(0,0,0);const s=w(r);b(t,a=>{if(s.current===r){const i=s.current;i.aspect=a.width/a.height,i.updateProjectionMatrix(),e()}});const n={camera:s};return V("threlte-camera-context",n),n},F=()=>{const t=y("threlte-camera-context");if(!t)throw new Error("useCamera can only be used in a child component to <Canvas>.");return t},bt=()=>{const t={removeObjectFromDisposal:e=>{t.disposableObjects.delete(e)},disposableObjectMounted:e=>{const r=t.disposableObjects.get(e);r?t.disposableObjects.set(e,r+1):t.disposableObjects.set(e,1)},disposableObjectUnmounted:e=>{const r=t.disposableObjects.get(e);r&&r>0&&(t.disposableObjects.set(e,r-1),r-1<=0&&(t.shouldDispose=!0))},disposableObjects:new Map,shouldDispose:!1,dispose:async(e=!1)=>{await Q(),!(!t.shouldDispose&&!e)&&(t.disposableObjects.forEach((r,s)=>{var n;(r===0||e)&&((n=s==null?void 0:s.dispose)==null||n.call(s),t.disposableObjects.delete(s))}),t.shouldDispose=!1)}};return R(()=>{t.dispose(!0)}),V("threlte-disposal-context",t),t},$=()=>{const t=y("threlte-disposal-context");if(!t)throw new Error("useDisposal can only be used in a child component to <Canvas>.");return t},ee=Symbol("threlte-parent-context"),Ae=t=>{const e=w(t);return V(ee,e),e},Oe=()=>y(ee),P=Symbol("threlte-parent-object3d-context"),xt=t=>{const e=J(t);return V(P,e),e},Ie=t=>{const e=y(P),r=S(t),s=N([r,e],([n,a])=>n??a);return V(P,s),r},Ke=()=>y(P);function ze(t,e,r){if(!Re)return{task:void 0,start:()=>{},stop:()=>{},started:J(!1)};let s,n,a;C.isKey(t)?(s=t,n=e,a=r):(s=Symbol("useTask"),n=t,a=e);const i=A();let o=i.mainStage;if(a){if(a.stage)if(C.isValue(a.stage))o=a.stage;else{const f=i.scheduler.getStage(a.stage);if(!f)throw new Error(`No stage found with key ${a.stage.toString()}`);o=f}else if(a.after)if(Array.isArray(a.after))for(let f=0;f<a.after.length;f++){const h=a.after[f];if(C.isValue(h)){o=h.stage;break}}else C.isValue(a.after)&&(o=a.after.stage);else if(a.before)if(Array.isArray(a.before))for(let f=0;f<a.before.length;f++){const h=a.before[f];if(C.isValue(h)){o=h.stage;break}}else C.isValue(a.before)&&(o=a.before.stage)}const d=S(!1),c=o.createTask(s,n,a),l=()=>{d.set(!0),((a==null?void 0:a.autoInvalidate)??!0)&&i.autoInvalidations.add(n),c.start()},u=()=>{d.set(!1),((a==null?void 0:a.autoInvalidate)??!0)&&i.autoInvalidations.delete(n),c.stop()};return(a==null?void 0:a.autoStart)??!0?l():u(),R(()=>{o&&o.removeTask(s)}),{task:c,start:l,stop:u,started:{subscribe:d.subscribe}}}const vt=t=>{const e={scene:new ae};return V("threlte-scene-context",e),e},te=()=>{const t=y("threlte-scene-context");if(!t)throw new Error("useScene can only be used in a child component to <Canvas>.");return t},yt=t=>{const{dispose:e}=$(),{camera:r}=F(),{scene:s}=te(),{invalidate:n,renderStage:a,autoRender:i,scheduler:o,resetFrameInvalidation:d}=A(),{size:c,canvas:l}=j(),u=t.createRenderer?t.createRenderer(l):new oe({canvas:l,powerPreference:"high-performance",antialias:!0,alpha:!0}),f=a.createTask(Symbol("threlte-auto-render-task"),()=>{u.render(s,r.current)}),h={renderer:u,colorManagementEnabled:w(t.colorManagementEnabled??!0),colorSpace:w(t.colorSpace??"srgb"),dpr:w(t.dpr??window.devicePixelRatio),shadows:w(t.shadows??O),toneMapping:w(t.toneMapping??_),autoRenderTask:f};V("threlte-renderer-context",h),b([h.colorManagementEnabled],([m])=>{ie.enabled=m}),b([h.colorSpace],([m])=>{"outputColorSpace"in u&&(u.outputColorSpace=m)}),b([h.dpr],([m])=>{"setPixelRatio"in u&&u.setPixelRatio(m)});const{start:k,stop:T}=ze(()=>{var m;!("xr"in u)||(m=u.xr)!=null&&m.isPresenting||(u.setSize(c.current.width,c.current.height),n(),T())},{before:f,autoStart:!1,autoInvalidate:!1});return b([c],()=>{k()}),b([h.shadows],([m])=>{"shadowMap"in u&&(u.shadowMap.enabled=!!m,m&&m!==!0?u.shadowMap.type=m:m===!0&&(u.shadowMap.type=O))}),b([h.toneMapping],([m])=>{"toneMapping"in u&&(u.toneMapping=m)}),b([i],([m])=>(m?h.autoRenderTask.start():h.autoRenderTask.stop(),()=>{h.autoRenderTask.stop()})),"setAnimationLoop"in h.renderer&&h.renderer.setAnimationLoop(E=>{e(),o.run(E),d()}),R(()=>{if("dispose"in h.renderer){const m=h.renderer.dispose;m()}}),M(()=>{h.colorManagementEnabled.set(t.colorManagementEnabled??!0)}),M(()=>{h.colorSpace.set(t.colorSpace??"srgb")}),M(()=>{h.toneMapping.set(t.toneMapping??_)}),M(()=>{h.shadows.set(t.shadows??O)}),M(()=>{h.dpr.set(t.dpr??window.devicePixelRatio)}),h},Ne=()=>{const t=y("threlte-renderer-context");if(!t)throw new Error("useRenderer can only be used in a child component to <Canvas>.");return t},W=()=>{const t=A(),e=Ne(),r=F(),s=te(),n=j();return{advance:t.advance,autoRender:t.autoRender,autoRenderTask:e.autoRenderTask,camera:r.camera,colorManagementEnabled:e.colorManagementEnabled,colorSpace:e.colorSpace,dpr:e.dpr,invalidate:t.invalidate,mainStage:t.mainStage,renderer:e.renderer,renderMode:t.renderMode,renderStage:t.renderStage,scheduler:t.scheduler,shadows:e.shadows,shouldRender:t.shouldRender,dom:n.dom,canvas:n.canvas,size:n.size,toneMapping:e.toneMapping,get scene(){return s.scene},set scene(i){s.scene=i}}},je=t=>typeof t=="object"&&t!==null,We=()=>{const{invalidate:t}=W();let e;const r=S(),s=Oe(),n=Ke(),a=Ae(),i=Ie();b([r,a,s,n],([c,l,u,f])=>{if(e==null||e(),e=void 0,!l){t();return}if(c!==void 0){if(c){if(typeof c=="function")e=c({ref:l,parent:u,parentObject3D:f});else if(v(c,"Object3D")&&v(l,"Object3D"))e=()=>c==null?void 0:c.remove(l),c==null||c.add(l);else if(typeof c=="string"){const{target:h,key:k}=Z(u,c),T=h[k];e=()=>h[k]=T,h[k]=l}}}else v(l,"Object3D")?(e=()=>f==null?void 0:f.remove(l),f==null||f.add(l)):je(u)&&(v(l,"Material")?u.material=l:v(l,"BufferGeometry")&&(u.geometry=l));t()});const o=c=>{r.set(c)},d=c=>{a.set(c),v(c,"Object3D")&&i.set(c)};return R(()=>{e==null||e(),t()}),{updateRef:d,updateAttach:o}},_e=t=>v(t,"PerspectiveCamera")||v(t,"OrthographicCamera"),Be=()=>{const{invalidate:t,size:e,camera:r}=W(),s=S(),n=S(!0),a=S(!1);return b([s,a],([c,l])=>{!c||!l||(r.set(c),t())}),b([s,n,e],([c,l,u])=>{!c||l||(v(c,"OrthographicCamera")?(c.left=u.width/-2,c.right=u.width/2,c.top=u.height/2,c.bottom=u.height/-2,c.updateProjectionMatrix(),c.updateMatrixWorld(),t()):v(c,"PerspectiveCamera")&&(c.aspect=u.width/u.height,c.updateProjectionMatrix(),c.updateMatrixWorld(),t()))}),{updateRef:c=>{_e(c)&&s.set(c)},updateManual:c=>{n.set(c)},updateMakeDefault:c=>{a.set(c)}}},Le=t=>{let e,r,s=!1;const n=()=>{e==null||e(),e=t==null?void 0:t(r)},a=i=>{r=i,s&&n()};return X(()=>{n(),s=!0}),R(()=>e==null?void 0:e()),{updateRef:a}},L=Symbol("threlte-disposable-object-context"),Ge=t=>typeof(t==null?void 0:t.dispose)=="function"&&!v(t,"Scene"),He=t=>{let e;const r=S(void 0),s=S(t),{disposableObjectMounted:n,disposableObjectUnmounted:a,removeObjectFromDisposal:i}=$(),o=y(L),d=N([s,o??S(!0)],([u,f])=>u??f??!0);return V(L,d),b([r,d],([u,f])=>{u===e?f?e&&n(e):e&&i(e):f&&(e&&a(e),u&&n(u)),e=u}),R(()=>{if(!K(d))return;const u=K(r);u&&a(u)}),{updateRef:u=>{Ge(u)&&r.set(u)},updateDispose:u=>{s.set(u)}}},Ue=t=>t!==null&&typeof t=="object"&&"addEventListener"in t&&"removeEventListener"in t,Qe=(t={})=>{const e=n=>{var a;n!=null&&n.type&&((a=t[`on${n.type}`])==null||a.call(t,n))},r=(n,a)=>{const i=[];for(const o of Object.keys(a))o.startsWith("on")&&(n.addEventListener(o.slice(2),e),i.push(o));return()=>{for(let o=0;o<i.length;o++)n.removeEventListener(i[o],e)}};return{updateRef:n=>{if(Ue(n))return r(n,t)}}};let z;const qe=t=>{z=t},Xe=()=>{const t=z;return z=void 0,t},Je=t=>{const r=y("threlte-plugin-context");if(!r)return;const s=[],n=Object.values(r);if(n.length){const a=t();for(let i=0;i<n.length;i++){const o=n[i],d=o(a);d&&d.pluginProps&&s.push(...d.pluginProps)}}return{pluginsProps:s}},Ye=new Set(["$$scope","$$slots","type","args","attach","instance"]),Ze=new Set(["fov","aspect","near","far","left","right","top","bottom","zoom"]),Fe=t=>typeof t=="string"||typeof t=="number"||typeof t=="boolean"||typeof t>"u"||t===null,G=(t,e,r)=>{var s,n,a;return!Array.isArray(r)&&typeof r=="number"&&typeof((s=t[e])==null?void 0:s.setScalar)=="function"&&!((n=t[e])!=null&&n.isColor)?(i,o,d)=>{i[o].setScalar(d)}:typeof((a=t[e])==null?void 0:a.set)=="function"?Array.isArray(r)?(i,o,d)=>{i[o].set(...d)}:(i,o,d)=>{i[o].set(d)}:(i,o,d)=>{i[o]=d}},$e=()=>{const{invalidate:t}=W(),e=new Map,r=new Map,s=(a,i,o,d)=>{if(Fe(o)){const u=e.get(i);if(u&&u.instance===a&&u.value===o)return;e.set(i,{instance:a,value:o})}const{key:c,target:l}=Z(a,i);if(o!=null){const u=r.get(i);if(u)u(l,c,o);else{const f=G(l,c,o);r.set(i,f),f(l,c,o)}}else G(l,c,o)(l,c,o);d.manualCamera||Ze.has(c)&&(l.isPerspectiveCamera||l.isOrthographicCamera)&&l.updateProjectionMatrix()};return{updateProp:(a,i,o,d)=>{var c;!Ye.has(i)&&!((c=d.pluginsProps)!=null&&c.includes(i))&&s(a,i,o,d),t()}}},et=/^\s*class\s+/,tt=t=>typeof t!="function"?!1:et.test(t.toString()),rt=t=>Array.isArray(t),st=(t,e)=>tt(t)?rt(e)?new t(...e):new t:t;function I(t,e){me(e,!0);let r=D(e,"is",19,Xe),s=D(e,"manual",3,!1),n=D(e,"makeDefault",3,!1),a=D(e,"ref",15),i=ve(e,["$$slots","$$events","$$legacy","is","args","attach","manual","makeDefault","dispose","ref","oncreate","children"]),o=q(()=>st(r(),e.args));const d=Le(e.oncreate);x(()=>{a()!==p(o)&&(a(p(o)),d.updateRef(p(o)))});const c=Je(()=>({get ref(){return p(o)},get args(){return e.args},get attach(){return e.attach},get manual(){return s()},get makeDefault(){return n()},get dispose(){return e.dispose},get props(){return i}})),{updateProp:l}=$e();Object.keys(i).forEach(E=>{x(()=>{l(p(o),E,i[E],{manualCamera:s(),pluginsProps:c==null?void 0:c.pluginsProps})})});const u=We();x(()=>u.updateAttach(e.attach)),x(()=>u.updateRef(p(o)));const f=Be();x(()=>f.updateRef(p(o))),x(()=>f.updateManual(s())),x(()=>f.updateMakeDefault(n()));const h=He(e.dispose);x(()=>h.updateRef(p(o))),x(()=>h.updateDispose(e.dispose));const k=Qe(i);x(()=>k.updateRef(p(o)));var T=ue(),m=ge(T);xe(m,()=>e.children??be,()=>({ref:p(o)})),de(t,T),pe()}const nt={},wt=new Proxy(function(){},{apply(t,e,r){return I(...r)},get(t,e){if(typeof e!="string")return I;const r=nt[e]||ce[e];if(r===void 0)throw new Error(`No Three.js module found for ${e}. Did you forget to extend the catalogue?`);return qe(r),I}});export{wt as T,W as a,Oe as b,w as c,Ke as d,Ie as e,Se as f,vt as g,mt as h,v as i,Ae as j,xt as k,bt as l,gt as m,pt as n,ht as o,yt as p,we as q,ze as u,b as w};
