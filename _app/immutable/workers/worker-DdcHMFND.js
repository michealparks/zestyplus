var D=Object.defineProperty;var M=(g,d,x)=>d in g?D(g,d,{enumerable:!0,configurable:!0,writable:!0,value:x}):g[d]=x;var n=(g,d,x)=>M(g,typeof d!="symbol"?d+"":d,x);(function(){"use strict";let g=0;const p=class p{constructor(t,i=0,e=0,s=0,h=0,o=0,l=0){n(this,"id");n(this,"type");n(this,"x");n(this,"y");n(this,"z");n(this,"vx");n(this,"vy");n(this,"vz");n(this,"grid");n(this,"localVelocity",{x:0,y:0,z:0});this.id=++g,this.type=t,this.x=i,this.y=e,this.z=s,this.vx=h,this.vy=o,this.vz=l}setGrid(t){this.grid=t}getType(){return this.type}getVelocity(){return Math.sqrt(this.vx*this.vx+this.vy*this.vy+this.vz*this.vz)}checkVelocity(t=1){const i=this.getVelocity();i>t&&i>0&&(this.vx=t*this.vx/i,this.vy=t*this.vy/i,this.vz=t*this.vz/i)}addVelocity(t,i,e){this.vx+=t,this.vy+=i,this.vz+=e}move(t,i,e,s){var a;this.checkVelocity(t);let h=this.x+this.vx,o=this.y+this.vy,l=this.z+this.vz;h=Math.max(0,h),h=Math.min(i,h),o=Math.max(0,o),o=Math.min(e,o),l=Math.max(0,l),l=Math.min(s,l),(a=this.grid)==null||a.moveEntity(this,h,o,l)}getDistance(t){const i=this.x-t.x,e=this.y-t.y,s=this.z-t.z;return Math.sqrt(i*i+e*e+s*s)}serialize(){const{id:t,type:i,x:e,y:s,z:h,vx:o,vy:l,vz:a}=this;return{id:t,type:i,x:e,y:s,z:h,vx:o,vy:l,vz:a}}updateData(t){var i;this.id==t.id&&(this.vx=t.vx,this.vy=t.vy,this.vz=t.vz,(i=this.grid)==null||i.moveEntity(this,t.x,t.y,t.z))}static deserialize(t){const i=new p(t.type,t.x,t.y,t.z,t.vx,t.vy,t.vz);return i.id=t.id,i}};n(p,"FLOCK_ENTITY",1),n(p,"OBSTACLE_ENTITY",1);let d=p;class x{constructor(t,i){n(this,"worldSize");n(this,"cellSize");n(this,"cellRowCount");n(this,"cellCount");n(this,"entityList",[]);this.worldSize=t,this.cellSize=i,this.cellRowCount=this.worldSize/this.cellSize|0,this.cellCount=this.cellRowCount*this.cellRowCount*this.cellRowCount,this.entityList=[];for(let e=0;e<this.cellCount;e+=1)this.entityList[e]=[]}getWorldSize(){return this.worldSize}getGridRowCount(){return this.cellRowCount}getGridIndex(t,i,e){let s=t/this.cellSize|0,h=i/this.cellSize|0,o=e/this.cellSize|0;return s<0?s=0:s>this.cellRowCount-1&&(s=this.cellRowCount-1),h<0?h=0:h>this.cellRowCount-1&&(h=this.cellRowCount-1),o<0?o=0:o>this.cellRowCount-1&&(o=this.cellRowCount-1),s+h*this.cellRowCount+o*this.cellRowCount*this.cellRowCount|0}addEntity(t){const i=this.getGridIndex(t.x,t.y,t.z)|0;t.setGrid(this),this.entityList[i].push(t)}removeEntity(t){const i=this.getGridIndex(t.x,t.y,t.z)|0,e=this.entityList[i],s=e.indexOf(t);if(s==-1)throw"removeEntity() can not find the entity to be removed!";e.splice(s,1),t.setGrid(void 0)}moveEntity(t,i,e,s){const h=this.getGridIndex(t.x,t.y,t.z)|0,o=this.getGridIndex(i,e,s)|0;if(h==o){t.x=i,t.y=e,t.z=s;return}const l=this.entityList[h],a=l.indexOf(t);if(a==-1)throw"moveEntity() can not find the entity to be removed!";l.splice(a,1),t.x=i,t.y=e,t.z=s,this.entityList[o].push(t)}getEntitiesInGrid(t,i,e){const s=this.getGridIndex(t,i,e)|0;return this.entityList[s]}getEntitiesInGridIndex(t){if(t<0||t>=this.cellCount)throw"getEntitiesInGridIndex() out of bounds!";return this.entityList[t|0]}getEntitiesInCube(t,i,e,s,h){const o=this.getGridIndex(t-s,i-s,e-s),l=this.getGridIndex(t+s,i-s,e-s),a=this.getGridIndex(t-s,i+s,e-s),r=this.getGridIndex(t+s,i+s,e+s),c=o,b=l-o+1,v=(a-o)/this.cellRowCount+1|0,f=(r-o)/(this.cellRowCount*this.cellRowCount)+1|0;for(let C=0;C<f;C++)for(let z=0;z<v;z++)for(let y=0;y<b;y++){const W=c+C*this.cellRowCount*this.cellRowCount+z*this.cellRowCount+y;if(W>=this.cellCount)continue;const I=this.entityList[W],k=I.length;for(let R=0;R<k;R++){const u=I[R];u!==void 0&&u.x>=t-s&&u.x<=t+s&&u.y>=i-s&&u.y<=i+s&&u.z>=e-s&&u.z<=e+s&&h(u)}}}}class m{constructor(t=500,i=500,e=500,s=1){n(this,"grid");n(this,"subDivisionCount");n(this,"flockEntities",[]);n(this,"obstacleEntities",[]);n(this,"boundaryX");n(this,"boundaryY");n(this,"boundaryZ");n(this,"aligmentWeight",2);n(this,"cohesionWeight",4);n(this,"separationWeight",.3);n(this,"maxEntitySpeed",5);n(this,"aligmentRadius",100);n(this,"cohesionRadius",100);n(this,"separationRadius",100);n(this,"obstacleRadius",100);const h=Math.max(t,i,e);this.grid=new x(h,h/s),this.subDivisionCount=s,this.boundaryX=t,this.boundaryY=i,this.boundaryZ=e}addFlockEntity(t){this.grid.addEntity(t),this.flockEntities.push(t)}getFlockEntities(){return this.flockEntities}addObstacleEntity(t){this.grid.addEntity(t),this.obstacleEntities.push(t)}getObstacleEntities(){return this.obstacleEntities}getBoundary(){return[this.boundaryX,this.boundaryY,this.boundaryZ]}setMaxSpeed(t){this.maxEntitySpeed=t}setAligmentWeight(t){this.aligmentWeight=t}setCohesionWeight(t){this.cohesionWeight=t}setSeparationWeight(t){this.separationWeight=t}setBoundary(t,i,e){this.boundaryX=t,this.boundaryY=i,this.boundaryZ=e}iterate(t=0,i=this.flockEntities.length){for(let e=t;e<i;e++){const s=this.flockEntities[e],h=this.computeAlignment(s),o=this.computeCohesion(s),l=this.computeSeparation(s),a=this.computeObstacles(s),r=this.aligmentWeight*h[0]+this.cohesionWeight*o[0]+50*this.separationWeight*l[0]+100*a[0],c=this.aligmentWeight*h[1]+this.cohesionWeight*o[1]+50*this.separationWeight*l[1]+100*a[1],b=this.aligmentWeight*h[2]+this.cohesionWeight*o[2]+50*this.separationWeight*l[2]+100*a[2];s.addVelocity(r,c,b),s.move(this.maxEntitySpeed,this.boundaryX,this.boundaryY,this.boundaryZ)}}computeAlignment(t){let i=0,e=0,s=0,h=0;if(this.grid.getEntitiesInCube(t.x,t.y,t.z,this.aligmentRadius,o=>{o!=t&&o.getType()==d.FLOCK_ENTITY&&t.getDistance(o)<this.aligmentRadius&&(h++,i+=o.vx,e+=o.vy,s+=o.vz)}),h>0){i/=h,e/=h,s/=h;const o=Math.sqrt(i*i+e*e+s*s);o>0&&(i/=o,e/=o,s/=o)}return[i,e,s]}computeCohesion(t){let i=0,e=0,s=0,h=0;if(this.grid.getEntitiesInCube(t.x,t.y,t.z,this.cohesionRadius,o=>{o!=t&&o.getType()==d.FLOCK_ENTITY&&t.getDistance(o)<this.cohesionRadius&&(h++,i+=o.x,e+=o.y,s+=o.z)}),h>0){i/=h,e/=h,s/=h,i=i-t.x,e=e-t.y,s=s-t.z;const o=Math.sqrt(i*i+e*e+s*s);o>0&&(i/=o,e/=o,s/=o)}return[i,e,s]}computeSeparation(t){let i=0,e=0,s=0;return this.grid.getEntitiesInCube(t.x,t.y,t.z,this.separationRadius,h=>{let o=t.getDistance(h);if(o<=0&&(o=.01),h!=t&&h.getType()==d.FLOCK_ENTITY&&o<this.separationRadius){const l=t.x-h.x,a=t.y-h.y,r=t.z-h.z;i+=l/o/o,e+=a/o/o,s+=r/o/o}}),[i,e,s]}computeObstacles(t){let i=0,e=0,s=0;this.grid.getEntitiesInCube(t.x,t.y,t.z,this.obstacleRadius,r=>{const c=t.getDistance(r);if(c>0&&r.getType()==d.OBSTACLE_ENTITY&&c<this.obstacleRadius){const b=t.x-r.x,v=t.y-r.y,f=t.z-r.z;i+=b/c/c,e+=v/c/c,s+=f/c/c}});const h=this.obstacleRadius/4,o=this.boundaryX-t.x,l=this.boundaryY-t.y,a=this.boundaryZ-t.z;return t.x<h&&Math.abs(t.x)>0?i+=1/t.x:o<h&&o>0&&(i-=1/o),t.y<h&&Math.abs(t.y)>0?e+=1/t.y:l<h&&l>0&&(e-=1/l),t.z<h&&Math.abs(t.z)>0?s+=1/t.z:a<h&&a>0&&(s-=1/a),[i,e,s]}serialize(){const t=[],i=[];return this.flockEntities.forEach(e=>{t.push(e.serialize())}),this.obstacleEntities.forEach(e=>{i.push(e.serialize())}),{subDivisionCount:this.subDivisionCount,boundaryX:this.boundaryX,boundaryY:this.boundaryY,boundaryZ:this.boundaryZ,flockEntities:t,obstacleEntities:i,aligmentWeight:this.aligmentWeight,cohesionWeight:this.cohesionWeight,separationWeight:this.separationWeight,maxEntitySpeed:this.maxEntitySpeed,aligmentRadius:this.aligmentRadius,cohesionRadius:this.cohesionRadius,separationRadius:this.separationRadius,obstacleRadius:this.obstacleRadius}}serializeBoidsData(t=0,i=this.flockEntities.length){const e=[];for(let s=t;s<i;s++)e.push(this.flockEntities[s].serialize());return{start:t,flockEntities:e}}applyBoidsData(t){const{start:i,flockEntities:e}=t;for(let s=0;s<e.length;s++){const h=this.flockEntities[i+s],o=e[s];h.id==o.id?h.updateData(o):console.log("ids do not match!")}}static deserialize(t){const i=new m(t.boundaryX,t.boundaryY,t.boundaryZ,t.subDivisionCount);return i.aligmentWeight=t.aligmentWeight,i.cohesionWeight=t.cohesionWeight,i.separationWeight=t.separationWeight,i.maxEntitySpeed=t.maxEntitySpeed,i.aligmentRadius=t.aligmentRadius,i.cohesionRadius=t.cohesionRadius,i.separationRadius=t.separationRadius,i.obstacleRadius=t.obstacleRadius,t.flockEntities.forEach(e=>{const s=d.deserialize(e);i.addFlockEntity(s)}),t.obstacleEntities.forEach(e=>{const s=d.deserialize(e);i.addObstacleEntity(s)}),i}}class w{constructor(){n(this,"boidsController")}initializeBoidsController(t){this.boidsController=m.deserialize(t)}iterateBoidsController(t,i,e){if(!this.boidsController)return;this.boidsController.aligmentWeight=e.aligmentWeight,this.boidsController.cohesionWeight=e.cohesionWeight,this.boidsController.separationWeight=e.separationWeight,this.boidsController.maxEntitySpeed=e.maxEntitySpeed,this.boidsController.iterate(t,i);const s=this.boidsController.serializeBoidsData(t,i);postMessage({action:"iterateCompleted",data:s})}updateBoidsData(t){var i;(i=this.boidsController)==null||i.applyBoidsData(t)}onMessage(t){t.data.action=="initialData"?this.initializeBoidsController(t.data.data):t.data.action=="iterate"?this.iterateBoidsController(t.data.start,t.data.end,t.data.config):t.data.action=="updateBoidsData"&&this.updateBoidsData(t.data.data)}}const E=new w;onmessage=E.onMessage.bind(E)})();
