import"./DsnmJJEf.js";import{s as Ve,g as Ce,Z as ie,aq as q,a0 as j,a6 as Fe,a1 as H,a2 as oe,a5 as Me,ac as ge,h as L,_ as ae,a4 as be,u as ee,$ as Te,a3 as J}from"./E4cMcrld.js";import{e as xe}from"./JUI-49jL.js";import{c as U}from"./B2tXmoWB.js";import{M as ke}from"./DwjUp6gR.js";import{gj as re,ao as Se,g2 as ze,g3 as Ae,g4 as Be,V as v,et as ye,a0 as Y,fD as De,ae as Ee,af as le,x as se,f_ as R,bg as Le,g0 as Re,e1 as je,aV as He,a as Ie,fZ as Ne,ah as Oe}from"./CpNDQYbB.js";import{u as qe,a as Ge,b as Qe,c as we,d as We,e as Ue,R as ve}from"./SedplUmi.js";import{k as Ze,w as Ke,A as ce,e as Je}from"./D23MK1AK.js";import{o as Xe,a as Ye}from"./D43QEHlF.js";import{s as $e}from"./DwTxxjll.js";import{p as O,a as he,r as et}from"./DdtPJMXq.js";import{i as tt}from"./BKdKABQE.js";import{a as nt}from"./CiTjjYL-.js";import"./DgaIWUFU.js";function st(z,e){e&&Ve(re,{...Ce(re),[z]:e})}function _e(z,e){ie(e,!0);let t=O(e,"shape",3,"convexHull"),n=O(e,"colliders",15);const o=new Se,{updateRef:s}=qe(e.oncreate),i=Ge(),a=Qe(),{world:l,addColliderToContext:c,removeColliderFromContext:h}=we(),u=We(),r=()=>{n()!==void 0&&(u.removeColliders(n()),n().forEach(m=>{h(m),l.removeCollider(m,!0)}),n(n().length=0,!0))},g={oncollisionenter:e.oncollisionenter,oncollisionexit:e.oncollisionexit,oncontact:e.oncontact,onsensorenter:e.onsensorenter,onsensorexit:e.onsensorexit},p=()=>{r(),n(Ze(o,t()??"convexHull",l,i,a)),n().forEach(m=>c(m,o,g)),u.registerColliders(n()),n().forEach(m=>{Ue(m,g,i?.userData?.events),m.setActiveCollisionTypes(Ke.ALL),m.setRestitution(e.restitution??0),m.setRestitutionCombineRule(e.restitutionCombineRule??ce.Average),m.setFriction(e.friction??.7),m.setFrictionCombineRule(e.frictionCombineRule??ce.Average),m.setSensor(e.sensor??!1),m.setContactForceEventThreshold(e.contactForceEventThreshold??0),e.density&&m.setDensity(e.density),e.mass&&(e.centerOfMass&&e.principalAngularInertia&&e.angularInertiaLocalFrame?m.setMassProperties(e.mass,{x:e.centerOfMass[0],y:e.centerOfMass[1],z:e.centerOfMass[2]},{x:e.principalAngularInertia[0],y:e.principalAngularInertia[1],z:e.principalAngularInertia[2]},Je(e.angularInertiaLocalFrame)):m.setMass(e.mass))}),s(n())},f=()=>p();Xe(()=>{p()}),Ye(r);const w=ze();Ae(o),Be(w,m=>(m?.add(o),()=>{m?.remove(o)}));var b={refresh:f},x=q(),V=j(x);return $e(V,()=>e.children??Fe,()=>({colliders:n()??[],refresh:f})),H(z,x),oe(b)}const $=0,it=1,ot=new v,ue=new ye,te=new Y,de=new v,X=new De;class at{constructor(){this.tolerance=-1,this.faces=[],this.newFaces=[],this.assigned=new me,this.unassigned=new me,this.vertices=[]}setFromPoints(e){if(e.length>=4){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.vertices.push(new rt(e[t]));this._compute()}return this}setFromObject(e){const t=[];return e.updateMatrixWorld(!0),e.traverse(function(n){const o=n.geometry;if(o!==void 0){const s=o.attributes.position;if(s!==void 0)for(let i=0,a=s.count;i<a;i++){const l=new v;l.fromBufferAttribute(s,i).applyMatrix4(n.matrixWorld),t.push(l)}}}),this.setFromPoints(t)}containsPoint(e){const t=this.faces;for(let n=0,o=t.length;n<o;n++)if(t[n].distanceToPoint(e)>this.tolerance)return!1;return!0}intersectRay(e,t){const n=this.faces;let o=-1/0,s=1/0;for(let i=0,a=n.length;i<a;i++){const l=n[i],c=l.distanceToPoint(e.origin),h=l.normal.dot(e.direction);if(c>0&&h>=0)return null;const u=h!==0?-c/h:0;if(!(u<=0)&&(h>0?s=Math.min(u,s):o=Math.max(u,o),o>s))return null}return o!==-1/0?e.at(o,t):e.at(s,t),t}intersectsRay(e){return this.intersectRay(e,ot)!==null}makeEmpty(){return this.faces=[],this.vertices=[],this}_addVertexToFace(e,t){return e.face=t,t.outside===null?this.assigned.append(e):this.assigned.insertBefore(t.outside,e),t.outside=e,this}_removeVertexFromFace(e,t){return e===t.outside&&(e.next!==null&&e.next.face===t?t.outside=e.next:t.outside=null),this.assigned.remove(e),this}_removeAllVerticesFromFace(e){if(e.outside!==null){const t=e.outside;let n=e.outside;for(;n.next!==null&&n.next.face===e;)n=n.next;return this.assigned.removeSubList(t,n),t.prev=n.next=null,e.outside=null,t}}_deleteFaceVertices(e,t){const n=this._removeAllVerticesFromFace(e);if(n!==void 0)if(t===void 0)this.unassigned.appendChain(n);else{let o=n;do{const s=o.next;t.distanceToPoint(o.point)>this.tolerance?this._addVertexToFace(o,t):this.unassigned.append(o),o=s}while(o!==null)}return this}_resolveUnassignedPoints(e){if(this.unassigned.isEmpty()===!1){let t=this.unassigned.first();do{const n=t.next;let o=this.tolerance,s=null;for(let i=0;i<e.length;i++){const a=e[i];if(a.mark===$){const l=a.distanceToPoint(t.point);if(l>o&&(o=l,s=a),o>1e3*this.tolerance)break}}s!==null&&this._addVertexToFace(t,s),t=n}while(t!==null)}return this}_computeExtremes(){const e=new v,t=new v,n=[],o=[];for(let s=0;s<3;s++)n[s]=o[s]=this.vertices[0];e.copy(this.vertices[0].point),t.copy(this.vertices[0].point);for(let s=0,i=this.vertices.length;s<i;s++){const a=this.vertices[s],l=a.point;for(let c=0;c<3;c++)l.getComponent(c)<e.getComponent(c)&&(e.setComponent(c,l.getComponent(c)),n[c]=a);for(let c=0;c<3;c++)l.getComponent(c)>t.getComponent(c)&&(t.setComponent(c,l.getComponent(c)),o[c]=a)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(e.x),Math.abs(t.x))+Math.max(Math.abs(e.y),Math.abs(t.y))+Math.max(Math.abs(e.z),Math.abs(t.z))),{min:n,max:o}}_computeInitialHull(){const e=this.vertices,t=this._computeExtremes(),n=t.min,o=t.max;let s=0,i=0;for(let r=0;r<3;r++){const g=o[r].point.getComponent(r)-n[r].point.getComponent(r);g>s&&(s=g,i=r)}const a=n[i],l=o[i];let c,h;s=0,ue.set(a.point,l.point);for(let r=0,g=this.vertices.length;r<g;r++){const p=e[r];if(p!==a&&p!==l){ue.closestPointToPoint(p.point,!0,de);const f=de.distanceToSquared(p.point);f>s&&(s=f,c=p)}}s=-1,te.setFromCoplanarPoints(a.point,l.point,c.point);for(let r=0,g=this.vertices.length;r<g;r++){const p=e[r];if(p!==a&&p!==l&&p!==c){const f=Math.abs(te.distanceToPoint(p.point));f>s&&(s=f,h=p)}}const u=[];if(te.distanceToPoint(h.point)<0){u.push(B.create(a,l,c),B.create(h,l,a),B.create(h,c,l),B.create(h,a,c));for(let r=0;r<3;r++){const g=(r+1)%3;u[r+1].getEdge(2).setTwin(u[0].getEdge(g)),u[r+1].getEdge(1).setTwin(u[g+1].getEdge(0))}}else{u.push(B.create(a,c,l),B.create(h,a,l),B.create(h,l,c),B.create(h,c,a));for(let r=0;r<3;r++){const g=(r+1)%3;u[r+1].getEdge(2).setTwin(u[0].getEdge((3-r)%3)),u[r+1].getEdge(0).setTwin(u[g+1].getEdge(1))}}for(let r=0;r<4;r++)this.faces.push(u[r]);for(let r=0,g=e.length;r<g;r++){const p=e[r];if(p!==a&&p!==l&&p!==c&&p!==h){s=this.tolerance;let f=null;for(let w=0;w<4;w++){const b=this.faces[w].distanceToPoint(p.point);b>s&&(s=b,f=this.faces[w])}f!==null&&this._addVertexToFace(p,f)}}return this}_reindexFaces(){const e=[];for(let t=0;t<this.faces.length;t++){const n=this.faces[t];n.mark===$&&e.push(n)}return this.faces=e,this}_nextVertexToAdd(){if(this.assigned.isEmpty()===!1){let e,t=0;const n=this.assigned.first().face;let o=n.outside;do{const s=n.distanceToPoint(o.point);s>t&&(t=s,e=o),o=o.next}while(o!==null&&o.face===n);return e}}_computeHorizon(e,t,n,o){this._deleteFaceVertices(n),n.mark=it;let s;t===null?s=t=n.getEdge(0):s=t.next;do{const i=s.twin,a=i.face;a.mark===$&&(a.distanceToPoint(e)>this.tolerance?this._computeHorizon(e,i,a,o):o.push(s)),s=s.next}while(s!==t);return this}_addAdjoiningFace(e,t){const n=B.create(e,t.tail(),t.head());return this.faces.push(n),n.getEdge(-1).setTwin(t.twin),n.getEdge(0)}_addNewFaces(e,t){this.newFaces=[];let n=null,o=null;for(let s=0;s<t.length;s++){const i=t[s],a=this._addAdjoiningFace(e,i);n===null?n=a:a.next.setTwin(o),this.newFaces.push(a.face),o=a}return n.next.setTwin(o),this}_addVertexToHull(e){const t=[];return this.unassigned.clear(),this._removeVertexFromFace(e,e.face),this._computeHorizon(e.point,null,e.face,t),this._addNewFaces(e,t),this._resolveUnassignedPoints(this.newFaces),this}_cleanup(){return this.assigned.clear(),this.unassigned.clear(),this.newFaces=[],this}_compute(){let e;for(this._computeInitialHull();(e=this._nextVertexToAdd())!==void 0;)this._addVertexToHull(e);return this._reindexFaces(),this._cleanup(),this}}class B{constructor(){this.normal=new v,this.midpoint=new v,this.area=0,this.constant=0,this.outside=null,this.mark=$,this.edge=null}static create(e,t,n){const o=new B,s=new ne(e,o),i=new ne(t,o),a=new ne(n,o);return s.next=a.prev=i,i.next=s.prev=a,a.next=i.prev=s,o.edge=s,o.compute()}getEdge(e){let t=this.edge;for(;e>0;)t=t.next,e--;for(;e<0;)t=t.prev,e++;return t}compute(){const e=this.edge.tail(),t=this.edge.head(),n=this.edge.next.head();return X.set(e.point,t.point,n.point),X.getNormal(this.normal),X.getMidpoint(this.midpoint),this.area=X.getArea(),this.constant=this.normal.dot(this.midpoint),this}distanceToPoint(e){return this.normal.dot(e)-this.constant}}class ne{constructor(e,t){this.vertex=e,this.prev=null,this.next=null,this.twin=null,this.face=t}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){const e=this.head(),t=this.tail();return t!==null?t.point.distanceTo(e.point):-1}lengthSquared(){const e=this.head(),t=this.tail();return t!==null?t.point.distanceToSquared(e.point):-1}setTwin(e){return this.twin=e,e.twin=this,this}}class rt{constructor(e){this.point=e,this.prev=null,this.next=null,this.face=null}}class me{constructor(){this.head=null,this.tail=null}first(){return this.head}last(){return this.tail}clear(){return this.head=this.tail=null,this}insertBefore(e,t){return t.prev=e.prev,t.next=e,t.prev===null?this.head=t:t.prev.next=t,e.prev=t,this}insertAfter(e,t){return t.prev=e,t.next=e.next,t.next===null?this.tail=t:t.next.prev=t,e.next=t,this}append(e){return this.head===null?this.head=e:this.tail.next=e,e.prev=this.tail,e.next=null,this.tail=e,this}appendChain(e){for(this.head===null?this.head=e:this.tail.next=e,e.prev=this.tail;e.next!==null;)e=e.next;return this.tail=e,this}remove(e){return e.prev===null?this.head=e.next:e.prev.next=e.next,e.next===null?this.tail=e.prev:e.next.prev=e.prev,this}removeSubList(e,t){return e.prev===null?this.head=t.next:e.prev.next=t.next,t.next===null?this.tail=e.prev:t.next.prev=e.prev,this}isEmpty(){return this.head===null}}class fe extends Ee{constructor(e=[]){super();const t=[],n=[],s=new at().setFromPoints(e).faces;for(let i=0;i<s.length;i++){const a=s[i];let l=a.edge;do{const c=l.head().point;t.push(c.x,c.y,c.z),n.push(a.normal.x,a.normal.y,a.normal.z),l=l.next}while(l!==a.edge)}this.setAttribute("position",new le(t,3)),this.setAttribute("normal",new le(n,3))}}const lt=new v;class Z{constructor(e=1.4,t=1e-4){this.minSizeForBreak=e,this.smallDelta=t,this.tempLine1=new ye,this.tempPlane1=new Y,this.tempPlane2=new Y,this.tempPlane_Cut=new Y,this.tempCM1=new v,this.tempCM2=new v,this.tempVector3=new v,this.tempVector3_2=new v,this.tempVector3_3=new v,this.tempVector3_P0=new v,this.tempVector3_P1=new v,this.tempVector3_P2=new v,this.tempVector3_N0=new v,this.tempVector3_N1=new v,this.tempVector3_AB=new v,this.tempVector3_CB=new v,this.tempResultObjects={object1:null,object2:null},this.segments=[];const n=900;for(let o=0;o<n;o++)this.segments[o]=!1}prepareBreakableObject(e,t,n,o,s){const i=e.userData;i.mass=t,i.velocity=n.clone(),i.angularVelocity=o.clone(),i.breakable=s}subdivideByImpact(e,t,n,o,s){const i=[],a=this.tempPlane1,l=this.tempPlane2;this.tempVector3.addVectors(t,n),a.setFromCoplanarPoints(t,e.position,this.tempVector3);const c=s+o,h=this;function u(r,g,p,f){if(Math.random()<f*.05||f>c){i.push(r);return}let w=Math.PI;f===0?(l.normal.copy(a.normal),l.constant=a.constant):f<=o?(w=(p-g)*(.2+.6*Math.random())+g,h.tempVector3_2.copy(e.position).sub(t).applyAxisAngle(n,w).add(t),l.setFromCoplanarPoints(t,h.tempVector3,h.tempVector3_2)):(w=(.5*(f&1)+.2*(2-Math.random()))*Math.PI,h.tempVector3_2.copy(t).sub(r.position).applyAxisAngle(n,w).add(r.position),h.tempVector3_3.copy(n).add(r.position),l.setFromCoplanarPoints(r.position,h.tempVector3_3,h.tempVector3_2)),h.cutByPlane(r,l,h.tempResultObjects);const b=h.tempResultObjects.object1,x=h.tempResultObjects.object2;b&&u(b,g,w,f+1),x&&u(x,w,p,f+1)}return u(e,0,2*Math.PI,0),i}cutByPlane(e,t,n){const o=e.geometry,s=o.attributes.position.array,i=o.attributes.normal.array,a=s.length/3;let l=a/3,c=o.getIndex();c&&(c=c.array,l=c.length/3);function h(d,y){const M=d*3+y;return c?c[M]:M}const u=[],r=[],g=this.smallDelta,p=a*a;for(let d=0;d<p;d++)this.segments[d]=!1;const f=this.tempVector3_P0,w=this.tempVector3_P1,b=this.tempVector3_N0,x=this.tempVector3_N1;for(let d=0;d<l-1;d++){const y=h(d,0),M=h(d,1),D=h(d,2);b.set(i[y],i[y]+1,i[y]+2);for(let k=d+1;k<l;k++){const S=h(k,0),E=h(k,1),K=h(k,2);x.set(i[S],i[S]+1,i[S]+2),1-b.dot(x)<g&&(y===S||y===E||y===K?M===S||M===E||M===K?(this.segments[y*a+M]=!0,this.segments[M*a+y]=!0):(this.segments[D*a+y]=!0,this.segments[y*a+D]=!0):(M===S||M===E||M===K)&&(this.segments[D*a+M]=!0,this.segments[M*a+D]=!0))}}const V=this.tempPlane_Cut;e.updateMatrix(),Z.transformPlaneToLocalSpace(t,e.matrix,V);for(let d=0;d<l;d++){const y=h(d,0),M=h(d,1),D=h(d,2);for(let k=0;k<3;k++){const S=k===0?y:k===1?M:D,E=k===0?M:k===1?D:y;if(this.segments[S*a+E])continue;this.segments[S*a+E]=!0,this.segments[E*a+S]=!0,f.set(s[3*S],s[3*S+1],s[3*S+2]),w.set(s[3*E],s[3*E+1],s[3*E+2]);let N=0,G=V.distanceToPoint(f);G>g?(N=2,r.push(f.clone())):G<-g?(N=1,u.push(f.clone())):(N=3,u.push(f.clone()),r.push(f.clone()));let Q=0;if(G=V.distanceToPoint(w),G>g?(Q=2,r.push(w.clone())):G<-g?(Q=1,u.push(w.clone())):(Q=3,u.push(w.clone()),r.push(w.clone())),N===1&&Q===2||N===2&&Q===1){this.tempLine1.start.copy(f),this.tempLine1.end.copy(w);let W=new v;if(W=V.intersectLine(this.tempLine1,W),W===null)return console.error("Internal error: segment does not intersect plane."),n.segmentedObject1=null,n.segmentedObject2=null,0;u.push(W),r.push(W.clone())}}}const m=e.userData.mass*.5;this.tempCM1.set(0,0,0);let C=0;const F=u.length;if(F>0){for(let d=0;d<F;d++)this.tempCM1.add(u[d]);this.tempCM1.divideScalar(F);for(let d=0;d<F;d++){const y=u[d];y.sub(this.tempCM1),C=Math.max(C,y.x,y.y,y.z)}this.tempCM1.add(e.position)}this.tempCM2.set(0,0,0);let P=0;const _=r.length;if(_>0){for(let d=0;d<_;d++)this.tempCM2.add(r[d]);this.tempCM2.divideScalar(_);for(let d=0;d<_;d++){const y=r[d];y.sub(this.tempCM2),P=Math.max(P,y.x,y.y,y.z)}this.tempCM2.add(e.position)}let T=null,A=null,I=0;return F>4&&(T=new se(new fe(u),e.material),T.position.copy(this.tempCM1),T.quaternion.copy(e.quaternion),this.prepareBreakableObject(T,m,e.userData.velocity,e.userData.angularVelocity,2*C>this.minSizeForBreak),I++),_>4&&(A=new se(new fe(r),e.material),A.position.copy(this.tempCM2),A.quaternion.copy(e.quaternion),this.prepareBreakableObject(A,m,e.userData.velocity,e.userData.angularVelocity,2*P>this.minSizeForBreak),I++),n.object1=T,n.object2=A,I}static transformFreeVector(e,t){const n=e.x,o=e.y,s=e.z,i=t.elements;return e.x=i[0]*n+i[4]*o+i[8]*s,e.y=i[1]*n+i[5]*o+i[9]*s,e.z=i[2]*n+i[6]*o+i[10]*s,e}static transformFreeVectorInverse(e,t){const n=e.x,o=e.y,s=e.z,i=t.elements;return e.x=i[0]*n+i[1]*o+i[2]*s,e.y=i[4]*n+i[5]*o+i[6]*s,e.z=i[8]*n+i[9]*o+i[10]*s,e}static transformTiedVectorInverse(e,t){const n=e.x,o=e.y,s=e.z,i=t.elements;return e.x=i[0]*n+i[1]*o+i[2]*s-i[12],e.y=i[4]*n+i[5]*o+i[6]*s-i[13],e.z=i[8]*n+i[9]*o+i[10]*s-i[14],e}static transformPlaneToLocalSpace(e,t,n){n.normal.copy(e.normal),n.constant=e.constant;const o=Z.transformTiedVectorInverse(e.coplanarPoint(lt),t);Z.transformFreeVectorInverse(n.normal,t),n.constant=-o.dot(n.normal)}}const pe=new Z;function Pe(z,e){ie(e,!0);let t=O(e,"fixed",3,!1),n=O(e,"depth",3,0),o=O(e,"maxDepth",3,1),s=O(e,"minBreakForce",3,100),i=et(e,["$$slots","$$events","$$legacy","fixed","velocity","angularVelocity","depth","maxDepth","minBreakForce","mesh"]),a=Me(ge([])),l=e.velocity,c=e.angularVelocity,h;n()===0&&pe.prepareBreakableObject(e.mesh,1,new v,new v,!0);let u,r;const g=C=>{if(n()>=o()||C.manifold.numContacts()===0)return;const P=C.manifold.localContactPoint1(0);P&&(u=new v(P.x,P.y,P.z))},p=new v,f=new Le,w=C=>{if(!u)return;if(C.totalForceMagnitude<s()){u=void 0;return}const F=C.maxForceDirection;if(r=new v(F.x,F.y,F.z),h){const _=h.linvel(),T=h.angvel();l=[_.x,_.y,_.z],c=[T.x,T.y,T.z]}be(a,pe.subdivideByImpact(e.mesh,u,r,2,1),!0);const P=e.mesh.parent;if(P){P.getWorldPosition(p),P.getWorldQuaternion(f);for(const _ of L(a))_.position.applyQuaternion(f),_.position.add(p),_.quaternion.premultiply(f),_.castShadow=_.receiveShadow=!0,_.material=e.mesh.material.clone()}u=void 0,r=void 0};var b=q(),x=j(b);{var V=C=>{{let F=ae(()=>t()?"fixed":"dynamic");ve(C,{get type(){return L(F)},oncollisionenter:g,oncontact:w,oncreate:P=>{h=P,e.velocity&&P.setLinvel({x:e.velocity[0],y:e.velocity[1],z:e.velocity[2]},!0),e.angularVelocity&&P.setAngvel({x:e.angularVelocity[0],y:e.angularVelocity[1],z:e.angularVelocity[2]},!0)},canSleep:!1,children:(P,_)=>{_e(P,{shape:"convexHull",children:(T,A)=>{R(T,he({get is(){return e.mesh}},()=>i))},$$slots:{default:!0}})},$$slots:{default:!0}})}},m=C=>{var F=q(),P=j(F);xe(P,17,()=>L(a),_=>_.uuid,(_,T)=>{var A=q(),I=j(A);U(I,()=>R.Group,(d,y)=>{y(d,{scale:.98,children:(M,D)=>{{let k=ae(()=>n()+1);Pe(M,he({get mesh(){return L(T)},get depth(){return L(k)},get maxDepth(){return o()},get minBreakForce(){return s()},get velocity(){return l},get angularVelocity(){return c}},()=>i))}},$$slots:{default:!0}})}),H(_,A)}),H(C,F)};tt(x,C=>{L(a).length===0?C(V):C(m,!1)})}H(z,b),oe()}var ct=Te("<!> <!> <!> <!> <!>",1);function ht(z,e){ie(e,!0);const{scene:t}=Re(),{world:n}=we(),o=nt(),s=()=>{const x=new ke;x.roughness=0;const V=new Oe,m=new se(V,x);return m.castShadow=m.receiveShadow=!0,m.visible=!1,m.quaternion.random(),m};let i=ge([s()]);ee(()=>{const{y:x}=n.gravity;return n.gravity.y=0,()=>n.gravity.y=x}),ee(()=>(t.fog=new je("#000",2,20),()=>t.fog=null));const a=new He;let l=performance.now(),c=performance.now();const h=new Ie;Ne(x=>{if(l+=x,o.level>.012&&l-c>2&&(c=l,i.push(s()),i.length>10&&i.shift()),o.level>.002){const V=[...u],m=V.length,C=V[Math.random()*m|0];if(C){const F=C.material;h.setHSL(Math.random(),1,.4),F.color.set(h)}}});const u=new Set;st("color",x=>{x.ref.isMesh&&ee(()=>(u.add(x.ref),()=>u.delete(x.ref)))});var r=ct(),g=j(r);U(g,()=>R.PerspectiveCamera,(x,V)=>{V(x,{makeDefault:!0,"position.y":1,"position.z":10,oncreate:m=>m.lookAt(0,0,0)})});var p=J(g,2);R(p,{get is(){return a},intensity:3,position:[5,5,5],castShadow:!0,"shadow.camera.left":-5,"shadow.camera.right":5,"shadow.camera.top":5,"shadow.camera.bottom":-5,"shadow.mapSize.width":4096,"shadow.mapSize.height":4096});var f=J(p,2);U(f,()=>R.AmbientLight,(x,V)=>{V(x,{intensity:.1})});var w=J(f,2);xe(w,17,()=>i,x=>x.uuid,(x,V)=>{Pe(x,{get mesh(){return L(V)},autoBreak:!0,minBreakForce:0,maxDepth:2,castShadow:!0,receiveShadow:!0})});var b=J(w,2);ve(b,{type:"fixed",children:(x,V)=>{_e(x,{shape:"cuboid",children:(m,C)=>{var F=q(),P=j(F);U(P,()=>R.Mesh,(_,T)=>{T(_,{visible:!1,children:(A,I)=>{var d=q(),y=j(d);U(y,()=>R.BoxGeometry,(M,D)=>{D(M,{args:[.05,.05,.05]})}),H(A,d)},$$slots:{default:!0}})}),H(m,F)},$$slots:{default:!0}})},$$slots:{default:!0}}),H(z,r),oe()}const Ft=Object.freeze(Object.defineProperty({__proto__:null,default:ht},Symbol.toStringTag,{value:"Module"}));export{ht as _,Ft as a};
