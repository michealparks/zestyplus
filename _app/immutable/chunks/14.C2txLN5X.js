import"./disclose-version.Bg9kRutz.js";import{p as ie,a9 as Ce,ab as Me,f as L,a2 as Ve,a as oe,a6 as ge,i as I,a5 as xe,k as re,b as le,s as U}from"./index-client.CAJtLLOW.js";import{c as J,a as R,t as ae}from"./template.CuXd8n4y.js";import{e as we,i as _e}from"./each.C1gUuVZd.js";import{c as q}from"./svelte-component.DNJIJZlw.js";import{p as O,a as ee,s as be,r as Te}from"./props.BHX9ZFdi.js";import{V as w,a4 as ve,P as Z,bq as Se,q as ke,F as ce,M as se,G as De,J as Ae,K as Ee,L as Be,s as ze,d as j,Q as Le,u as Re,C as Ie,h as je,a$ as He,a8 as Ne,bh as qe}from"./T.Dho_lh33.js";import{W as Oe}from"./World.CCwJ8epd.js";import{u as Ge,a as We,b as Qe,c as Ue,d as Je,l as Ke,f as Xe,o as Ye,A as he,e as Ze,i as ye}from"./createCollidersFromChildren.DAmjNsIo.js";import{i as $e}from"./if.BKnHbTGz.js";import{L as et}from"./Lightformer.sczCrPQI.js";import{a as tt}from"./auth.svelte.DwNCDtT_.js";import{h as nt}from"./color.D7bleQK4.js";const $=0,st=1,it=new w,ue=new ve,te=new Z,de=new w,Y=new Se;class ot{constructor(){this.tolerance=-1,this.faces=[],this.newFaces=[],this.assigned=new me,this.unassigned=new me,this.vertices=[]}setFromPoints(e){if(e.length>=4){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.vertices.push(new at(e[t]));this.compute()}return this}setFromObject(e){const t=[];return e.updateMatrixWorld(!0),e.traverse(function(n){const i=n.geometry;if(i!==void 0){const s=i.attributes.position;if(s!==void 0)for(let o=0,a=s.count;o<a;o++){const l=new w;l.fromBufferAttribute(s,o).applyMatrix4(n.matrixWorld),t.push(l)}}}),this.setFromPoints(t)}containsPoint(e){const t=this.faces;for(let n=0,i=t.length;n<i;n++)if(t[n].distanceToPoint(e)>this.tolerance)return!1;return!0}intersectRay(e,t){const n=this.faces;let i=-1/0,s=1/0;for(let o=0,a=n.length;o<a;o++){const l=n[o],c=l.distanceToPoint(e.origin),h=l.normal.dot(e.direction);if(c>0&&h>=0)return null;const f=h!==0?-c/h:0;if(!(f<=0)&&(h>0?s=Math.min(f,s):i=Math.max(f,i),i>s))return null}return i!==-1/0?e.at(i,t):e.at(s,t),t}intersectsRay(e){return this.intersectRay(e,it)!==null}makeEmpty(){return this.faces=[],this.vertices=[],this}addVertexToFace(e,t){return e.face=t,t.outside===null?this.assigned.append(e):this.assigned.insertBefore(t.outside,e),t.outside=e,this}removeVertexFromFace(e,t){return e===t.outside&&(e.next!==null&&e.next.face===t?t.outside=e.next:t.outside=null),this.assigned.remove(e),this}removeAllVerticesFromFace(e){if(e.outside!==null){const t=e.outside;let n=e.outside;for(;n.next!==null&&n.next.face===e;)n=n.next;return this.assigned.removeSubList(t,n),t.prev=n.next=null,e.outside=null,t}}deleteFaceVertices(e,t){const n=this.removeAllVerticesFromFace(e);if(n!==void 0)if(t===void 0)this.unassigned.appendChain(n);else{let i=n;do{const s=i.next;t.distanceToPoint(i.point)>this.tolerance?this.addVertexToFace(i,t):this.unassigned.append(i),i=s}while(i!==null)}return this}resolveUnassignedPoints(e){if(this.unassigned.isEmpty()===!1){let t=this.unassigned.first();do{const n=t.next;let i=this.tolerance,s=null;for(let o=0;o<e.length;o++){const a=e[o];if(a.mark===$){const l=a.distanceToPoint(t.point);if(l>i&&(i=l,s=a),i>1e3*this.tolerance)break}}s!==null&&this.addVertexToFace(t,s),t=n}while(t!==null)}return this}computeExtremes(){const e=new w,t=new w,n=[],i=[];for(let s=0;s<3;s++)n[s]=i[s]=this.vertices[0];e.copy(this.vertices[0].point),t.copy(this.vertices[0].point);for(let s=0,o=this.vertices.length;s<o;s++){const a=this.vertices[s],l=a.point;for(let c=0;c<3;c++)l.getComponent(c)<e.getComponent(c)&&(e.setComponent(c,l.getComponent(c)),n[c]=a);for(let c=0;c<3;c++)l.getComponent(c)>t.getComponent(c)&&(t.setComponent(c,l.getComponent(c)),i[c]=a)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(e.x),Math.abs(t.x))+Math.max(Math.abs(e.y),Math.abs(t.y))+Math.max(Math.abs(e.z),Math.abs(t.z))),{min:n,max:i}}computeInitialHull(){const e=this.vertices,t=this.computeExtremes(),n=t.min,i=t.max;let s=0,o=0;for(let r=0;r<3;r++){const m=i[r].point.getComponent(r)-n[r].point.getComponent(r);m>s&&(s=m,o=r)}const a=n[o],l=i[o];let c,h;s=0,ue.set(a.point,l.point);for(let r=0,m=this.vertices.length;r<m;r++){const g=e[r];if(g!==a&&g!==l){ue.closestPointToPoint(g.point,!0,de);const d=de.distanceToSquared(g.point);d>s&&(s=d,c=g)}}s=-1,te.setFromCoplanarPoints(a.point,l.point,c.point);for(let r=0,m=this.vertices.length;r<m;r++){const g=e[r];if(g!==a&&g!==l&&g!==c){const d=Math.abs(te.distanceToPoint(g.point));d>s&&(s=d,h=g)}}const f=[];if(te.distanceToPoint(h.point)<0){f.push(S.create(a,l,c),S.create(h,l,a),S.create(h,c,l),S.create(h,a,c));for(let r=0;r<3;r++){const m=(r+1)%3;f[r+1].getEdge(2).setTwin(f[0].getEdge(m)),f[r+1].getEdge(1).setTwin(f[m+1].getEdge(0))}}else{f.push(S.create(a,c,l),S.create(h,a,l),S.create(h,l,c),S.create(h,c,a));for(let r=0;r<3;r++){const m=(r+1)%3;f[r+1].getEdge(2).setTwin(f[0].getEdge((3-r)%3)),f[r+1].getEdge(0).setTwin(f[m+1].getEdge(1))}}for(let r=0;r<4;r++)this.faces.push(f[r]);for(let r=0,m=e.length;r<m;r++){const g=e[r];if(g!==a&&g!==l&&g!==c&&g!==h){s=this.tolerance;let d=null;for(let v=0;v<4;v++){const M=this.faces[v].distanceToPoint(g.point);M>s&&(s=M,d=this.faces[v])}d!==null&&this.addVertexToFace(g,d)}}return this}reindexFaces(){const e=[];for(let t=0;t<this.faces.length;t++){const n=this.faces[t];n.mark===$&&e.push(n)}return this.faces=e,this}nextVertexToAdd(){if(this.assigned.isEmpty()===!1){let e,t=0;const n=this.assigned.first().face;let i=n.outside;do{const s=n.distanceToPoint(i.point);s>t&&(t=s,e=i),i=i.next}while(i!==null&&i.face===n);return e}}computeHorizon(e,t,n,i){this.deleteFaceVertices(n),n.mark=st;let s;t===null?s=t=n.getEdge(0):s=t.next;do{const o=s.twin,a=o.face;a.mark===$&&(a.distanceToPoint(e)>this.tolerance?this.computeHorizon(e,o,a,i):i.push(s)),s=s.next}while(s!==t);return this}addAdjoiningFace(e,t){const n=S.create(e,t.tail(),t.head());return this.faces.push(n),n.getEdge(-1).setTwin(t.twin),n.getEdge(0)}addNewFaces(e,t){this.newFaces=[];let n=null,i=null;for(let s=0;s<t.length;s++){const o=t[s],a=this.addAdjoiningFace(e,o);n===null?n=a:a.next.setTwin(i),this.newFaces.push(a.face),i=a}return n.next.setTwin(i),this}addVertexToHull(e){const t=[];return this.unassigned.clear(),this.removeVertexFromFace(e,e.face),this.computeHorizon(e.point,null,e.face,t),this.addNewFaces(e,t),this.resolveUnassignedPoints(this.newFaces),this}cleanup(){return this.assigned.clear(),this.unassigned.clear(),this.newFaces=[],this}compute(){let e;for(this.computeInitialHull();(e=this.nextVertexToAdd())!==void 0;)this.addVertexToHull(e);return this.reindexFaces(),this.cleanup(),this}}class S{constructor(){this.normal=new w,this.midpoint=new w,this.area=0,this.constant=0,this.outside=null,this.mark=$,this.edge=null}static create(e,t,n){const i=new S,s=new ne(e,i),o=new ne(t,i),a=new ne(n,i);return s.next=a.prev=o,o.next=s.prev=a,a.next=o.prev=s,i.edge=s,i.compute()}getEdge(e){let t=this.edge;for(;e>0;)t=t.next,e--;for(;e<0;)t=t.prev,e++;return t}compute(){const e=this.edge.tail(),t=this.edge.head(),n=this.edge.next.head();return Y.set(e.point,t.point,n.point),Y.getNormal(this.normal),Y.getMidpoint(this.midpoint),this.area=Y.getArea(),this.constant=this.normal.dot(this.midpoint),this}distanceToPoint(e){return this.normal.dot(e)-this.constant}}class ne{constructor(e,t){this.vertex=e,this.prev=null,this.next=null,this.twin=null,this.face=t}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){const e=this.head(),t=this.tail();return t!==null?t.point.distanceTo(e.point):-1}lengthSquared(){const e=this.head(),t=this.tail();return t!==null?t.point.distanceToSquared(e.point):-1}setTwin(e){return this.twin=e,e.twin=this,this}}class at{constructor(e){this.point=e,this.prev=null,this.next=null,this.face=null}}class me{constructor(){this.head=null,this.tail=null}first(){return this.head}last(){return this.tail}clear(){return this.head=this.tail=null,this}insertBefore(e,t){return t.prev=e.prev,t.next=e,t.prev===null?this.head=t:t.prev.next=t,e.prev=t,this}insertAfter(e,t){return t.prev=e,t.next=e.next,t.next===null?this.tail=t:t.next.prev=t,e.next=t,this}append(e){return this.head===null?this.head=e:this.tail.next=e,e.prev=this.tail,e.next=null,this.tail=e,this}appendChain(e){for(this.head===null?this.head=e:this.tail.next=e,e.prev=this.tail;e.next!==null;)e=e.next;return this.tail=e,this}remove(e){return e.prev===null?this.head=e.next:e.prev.next=e.next,e.next===null?this.tail=e.prev:e.next.prev=e.prev,this}removeSubList(e,t){return e.prev===null?this.head=t.next:e.prev.next=t.next,t.next===null?this.tail=e.prev:t.next.prev=e.prev,this}isEmpty(){return this.head===null}}class fe extends ke{constructor(e=[]){super();const t=[],n=[],s=new ot().setFromPoints(e).faces;for(let o=0;o<s.length;o++){const a=s[o];let l=a.edge;do{const c=l.head().point;t.push(c.x,c.y,c.z),n.push(a.normal.x,a.normal.y,a.normal.z),l=l.next}while(l!==a.edge)}this.setAttribute("position",new ce(t,3)),this.setAttribute("normal",new ce(n,3))}}const rt=new w;class K{constructor(e=1.4,t=1e-4){this.minSizeForBreak=e,this.smallDelta=t,this.tempLine1=new ve,this.tempPlane1=new Z,this.tempPlane2=new Z,this.tempPlane_Cut=new Z,this.tempCM1=new w,this.tempCM2=new w,this.tempVector3=new w,this.tempVector3_2=new w,this.tempVector3_3=new w,this.tempVector3_P0=new w,this.tempVector3_P1=new w,this.tempVector3_P2=new w,this.tempVector3_N0=new w,this.tempVector3_N1=new w,this.tempVector3_AB=new w,this.tempVector3_CB=new w,this.tempResultObjects={object1:null,object2:null},this.segments=[];const n=30*30;for(let i=0;i<n;i++)this.segments[i]=!1}prepareBreakableObject(e,t,n,i,s){const o=e.userData;o.mass=t,o.velocity=n.clone(),o.angularVelocity=i.clone(),o.breakable=s}subdivideByImpact(e,t,n,i,s){const o=[],a=this.tempPlane1,l=this.tempPlane2;this.tempVector3.addVectors(t,n),a.setFromCoplanarPoints(t,e.position,this.tempVector3);const c=s+i,h=this;function f(r,m,g,d){if(Math.random()<d*.05||d>c){o.push(r);return}let v=Math.PI;d===0?(l.normal.copy(a.normal),l.constant=a.constant):d<=i?(v=(g-m)*(.2+.6*Math.random())+m,h.tempVector3_2.copy(e.position).sub(t).applyAxisAngle(n,v).add(t),l.setFromCoplanarPoints(t,h.tempVector3,h.tempVector3_2)):(v=(.5*(d&1)+.2*(2-Math.random()))*Math.PI,h.tempVector3_2.copy(t).sub(r.position).applyAxisAngle(n,v).add(r.position),h.tempVector3_3.copy(n).add(r.position),l.setFromCoplanarPoints(r.position,h.tempVector3_3,h.tempVector3_2)),h.cutByPlane(r,l,h.tempResultObjects);const M=h.tempResultObjects.object1,y=h.tempResultObjects.object2;M&&f(M,m,v,d+1),y&&f(y,v,g,d+1)}return f(e,0,2*Math.PI,0),o}cutByPlane(e,t,n){const i=e.geometry,s=i.attributes.position.array,o=i.attributes.normal.array,a=s.length/3;let l=a/3,c=i.getIndex();c&&(c=c.array,l=c.length/3);function h(p,x){const F=p*3+x;return c?c[F]:F}const f=[],r=[],m=this.smallDelta,g=a*a;for(let p=0;p<g;p++)this.segments[p]=!1;const d=this.tempVector3_P0,v=this.tempVector3_P1,M=this.tempVector3_N0,y=this.tempVector3_N1;for(let p=0;p<l-1;p++){const x=h(p,0),F=h(p,1),T=h(p,2);M.set(o[x],o[x]+1,o[x]+2);for(let C=p+1;C<l;C++){const _=h(C,0),D=h(C,1),X=h(C,2);y.set(o[_],o[_]+1,o[_]+2),1-M.dot(y)<m&&(x===_||x===D||x===X?F===_||F===D||F===X?(this.segments[x*a+F]=!0,this.segments[F*a+x]=!0):(this.segments[T*a+x]=!0,this.segments[x*a+T]=!0):(F===_||F===D||F===X)&&(this.segments[T*a+F]=!0,this.segments[F*a+T]=!0))}}const u=this.tempPlane_Cut;e.updateMatrix(),K.transformPlaneToLocalSpace(t,e.matrix,u);for(let p=0;p<l;p++){const x=h(p,0),F=h(p,1),T=h(p,2);for(let C=0;C<3;C++){const _=C===0?x:C===1?F:T,D=C===0?F:C===1?T:x;if(this.segments[_*a+D])continue;this.segments[_*a+D]=!0,this.segments[D*a+_]=!0,d.set(s[3*_],s[3*_+1],s[3*_+2]),v.set(s[3*D],s[3*D+1],s[3*D+2]);let N=0,G=u.distanceToPoint(d);G>m?(N=2,r.push(d.clone())):G<-m?(N=1,f.push(d.clone())):(N=3,f.push(d.clone()),r.push(d.clone()));let W=0;if(G=u.distanceToPoint(v),G>m?(W=2,r.push(v.clone())):G<-m?(W=1,f.push(v.clone())):(W=3,f.push(v.clone()),r.push(v.clone())),N===1&&W===2||N===2&&W===1){this.tempLine1.start.copy(d),this.tempLine1.end.copy(v);let Q=new w;if(Q=u.intersectLine(this.tempLine1,Q),Q===null)return console.error("Internal error: segment does not intersect plane."),n.segmentedObject1=null,n.segmentedObject2=null,0;f.push(Q),r.push(Q.clone())}}}const P=e.userData.mass*.5;this.tempCM1.set(0,0,0);let V=0;const b=f.length;if(b>0){for(let p=0;p<b;p++)this.tempCM1.add(f[p]);this.tempCM1.divideScalar(b);for(let p=0;p<b;p++){const x=f[p];x.sub(this.tempCM1),V=Math.max(V,x.x,x.y,x.z)}this.tempCM1.add(e.position)}this.tempCM2.set(0,0,0);let A=0;const E=r.length;if(E>0){for(let p=0;p<E;p++)this.tempCM2.add(r[p]);this.tempCM2.divideScalar(E);for(let p=0;p<E;p++){const x=r[p];x.sub(this.tempCM2),A=Math.max(A,x.x,x.y,x.z)}this.tempCM2.add(e.position)}let B=null,z=null,H=0;return b>4&&(B=new se(new fe(f),e.material),B.position.copy(this.tempCM1),B.quaternion.copy(e.quaternion),this.prepareBreakableObject(B,P,e.userData.velocity,e.userData.angularVelocity,2*V>this.minSizeForBreak),H++),E>4&&(z=new se(new fe(r),e.material),z.position.copy(this.tempCM2),z.quaternion.copy(e.quaternion),this.prepareBreakableObject(z,P,e.userData.velocity,e.userData.angularVelocity,2*A>this.minSizeForBreak),H++),n.object1=B,n.object2=z,H}static transformFreeVector(e,t){const n=e.x,i=e.y,s=e.z,o=t.elements;return e.x=o[0]*n+o[4]*i+o[8]*s,e.y=o[1]*n+o[5]*i+o[9]*s,e.z=o[2]*n+o[6]*i+o[10]*s,e}static transformFreeVectorInverse(e,t){const n=e.x,i=e.y,s=e.z,o=t.elements;return e.x=o[0]*n+o[1]*i+o[2]*s,e.y=o[4]*n+o[5]*i+o[6]*s,e.z=o[8]*n+o[9]*i+o[10]*s,e}static transformTiedVectorInverse(e,t){const n=e.x,i=e.y,s=e.z,o=t.elements;return e.x=o[0]*n+o[1]*i+o[2]*s-o[12],e.y=o[4]*n+o[5]*i+o[6]*s-o[13],e.z=o[8]*n+o[9]*i+o[10]*s-o[14],e}static transformPlaneToLocalSpace(e,t,n){n.normal.copy(e.normal),n.constant=e.constant;const i=K.transformTiedVectorInverse(e.coplanarPoint(rt),t);K.transformFreeVectorInverse(n.normal,t),n.constant=-i.dot(n.normal)}}function Pe(k,e){ie(e,!0);let t=O(e,"shape",3,"convexHull"),n=O(e,"colliders",15);const i=new De,{updateRef:s}=Ge(e.oncreate),o=We(),a=Qe(),{world:l,addColliderToContext:c,removeColliderFromContext:h}=Ue(),f=Je(),r=()=>{n()!==void 0&&(f.removeColliders(n()),n().forEach(u=>{h(u),l.removeCollider(u,!0)}),n(n().length=0,!0))},m={oncollisionenter:e.oncollisionenter,oncollisionexit:e.oncollisionexit,oncontact:e.oncontact,onsensorenter:e.onsensorenter,onsensorexit:e.onsensorexit},g=()=>{r(),n(Ke(i,t()??"convexHull",l,o,a)),n().forEach(u=>c(u,i,m)),f.registerColliders(n()),n().forEach(u=>{var P;Xe(u,m,(P=o==null?void 0:o.userData)==null?void 0:P.events),u.setActiveCollisionTypes(Ye.ALL),u.setRestitution(e.restitution??0),u.setRestitutionCombineRule(e.restitutionCombineRule??he.Average),u.setFriction(e.friction??.7),u.setFrictionCombineRule(e.frictionCombineRule??he.Average),u.setSensor(e.sensor??!1),u.setContactForceEventThreshold(e.contactForceEventThreshold??0),e.density&&u.setDensity(e.density),e.mass&&(e.centerOfMass&&e.principalAngularInertia&&e.angularInertiaLocalFrame?u.setMassProperties(e.mass,{x:e.centerOfMass[0],y:e.centerOfMass[1],z:e.centerOfMass[2]},{x:e.principalAngularInertia[0],y:e.principalAngularInertia[1],z:e.principalAngularInertia[2]},Ze(e.angularInertiaLocalFrame)):u.setMass(e.mass))}),s(n())},d=()=>g();Ce(()=>{g()}),Me(r);const v=Ae();Ee(i),Be(v,u=>(u==null||u.add(i),()=>{u==null||u.remove(i)}));var M=J(),y=L(M);return ze(y,()=>e.children??Ve,()=>({colliders:n()??[],refresh:d})),R(k,M),oe({refresh:d})}const pe=new K;function Fe(k,e){ie(e,!0);let t=O(e,"fixed",3,!1),n=O(e,"depth",3,0),i=O(e,"maxDepth",3,1),s=O(e,"minBreakForce",3,100),o=Te(e,["$$slots","$$events","$$legacy","fixed","depth","maxDepth","minBreakForce","mesh"]),a=ge(ee([]));n()===0&&pe.prepareBreakableObject(e.mesh,1,new w,new w,!0);let l,c;const h=y=>{if(n()>=i()||y.manifold.numContacts()===0)return;const P=y.manifold.localContactPoint1(0);P&&(l=new w(P.x,P.y,P.z))},f=new w,r=new Le;new w;const m=y=>{if(!l)return;if(y.totalForceMagnitude<s()){l=void 0;return}const u=y.maxForceDirection;c=new w(u.x,u.y,u.z),xe(a,ee(pe.subdivideByImpact(e.mesh,l,c,2,1)));const P=e.mesh.parent;P.getWorldPosition(f),P.getWorldQuaternion(r);for(const V of I(a))V.quaternion.copy(r),V.position.add(f),V.castShadow=V.receiveShadow=!0};var g=J(),d=L(g);{var v=y=>{var u=re(()=>t()?"fixed":"dynamic");ye(y,be({get type(){return I(u)},oncollisionenter:h,oncontact:m,canSleep:!1},()=>o,{children:(P,V)=>{Pe(P,{shape:"convexHull",children:(b,A)=>{j(b,{get is(){return e.mesh}})},$$slots:{default:!0}})},$$slots:{default:!0}}))},M=y=>{var u=J(),P=L(u);we(P,17,()=>I(a),V=>V.uuid,(V,b)=>{var A=J(),E=L(A);q(E,()=>j.Group,(B,z)=>{z(B,{scale:.98,children:(H,p)=>{var x=re(()=>n()+1);Fe(H,{get mesh(){return I(b)},get depth(){return I(x)},get maxDepth(){return i()},get minBreakForce(){return s()}})},$$slots:{default:!0}})}),R(V,A)}),R(y,u)};$e(d,y=>{I(a).length===0?y(v):y(M,!1)})}R(k,g),oe()}var lt=ae("<!> <!>",1),ct=ae("<!> <!>",1),ht=ae("<!> <!> <!> <!>",1);function ut(k,e){ie(e,!0);const{scene:t}=Re(),{frequencyData:n}=tt(),i=()=>{const m=new He;m.roughness=.1;const g=new Ne,d=new se(g,m);return d.castShadow=d.receiveShadow=!0,d.position.y=3,d};let s=ee([i()]);le(()=>{const m=setInterval(()=>s.push(i()),2e4);return()=>clearInterval(m)}),le(()=>(t.fog=new qe("#000",2,10),()=>t.fog=null));let o=new Ie("#FF4F4F"),a=ge(void 0);je(()=>{xe(a,ee(nt(o,n.current[32]/100)))});var l=ht(),c=L(l);q(c,()=>j.PerspectiveCamera,(m,g)=>{g(m,{makeDefault:!0,"position.y":1,"position.z":5,oncreate:d=>d.lookAt(0,0,0)})});var h=U(c,2);q(h,()=>j.DirectionalLight,(m,g)=>{g(m,{intensity:.5,position:[1,1,1],castShadow:!0})});var f=U(h,2);Oe(f,{gravity:[0,-1,0],children:(m,g)=>{var d=ct(),v=L(d);we(v,17,()=>s,_e,(y,u)=>{Fe(y,{get mesh(){return I(u)},minBreakForce:.1,maxDepth:2})});var M=U(v,2);ye(M,{type:"fixed",children:(y,u)=>{Pe(y,{shape:"cuboid",children:(P,V)=>{var b=J(),A=L(b);q(A,()=>j.Mesh,(E,B)=>{B(E,{"position.y":-1,receiveShadow:!0,children:(z,H)=>{var p=lt(),x=L(p);q(x,()=>j.BoxGeometry,(T,C)=>{C(T,{args:[20,.1,20]})});var F=U(x,2);q(F,()=>j.MeshStandardMaterial,(T,C)=>{C(T,{roughness:.1})}),R(z,p)},$$slots:{default:!0}})}),R(P,b)},$$slots:{default:!0}})},$$slots:{default:!0}}),R(m,d)},$$slots:{default:!0}});var r=U(f,2);et(r,{}),R(k,l),oe()}const Vt=Object.freeze(Object.defineProperty({__proto__:null,default:ut},Symbol.toStringTag,{value:"Module"}));export{ut as _,Vt as a};
