import"./DsnmJJEf.js";import{Z as q,b as k,g as s,_ as w,a2 as D,aq as $,a0 as F,a6 as H,a1 as U,$ as E,a3 as z,u as ee,a4 as te,a5 as ae}from"./Dj-DrZoY.js";import{c as Z}from"./DY0mOCK0.js";import{f_ as y,e0 as re,fc as se,eT as oe,V as X,a as N,ae as ne,fZ as Q,fb as ie,fk as ce,ad as G,bP as le,g0 as ue,ed as de,M as fe,bg as me,aV as he}from"./C4vSLsTb.js";import{a as pe}from"./CtZujQWG.js";import{h as Y}from"./D7bleQK4.js";import{f as ge}from"./CClPch6m.js";import{s as R}from"./B9m9H9kW.js";import{p as i,a as W,r as J}from"./HA0OJ1C7.js";import{a as ve}from"./CpLlC-Sb.js";import{L as _e}from"./COlMNsbs.js";function Me(L,e){q(e,!0);let n=i(e,"args",19,()=>[]),S=i(e,"radius",3,.05),p=i(e,"smoothness",3,4),t=i(e,"creaseAngle",3,.4),g=i(e,"steps",3,1),M=i(e,"ref",15),b=J(e,["$$slots","$$events","$$legacy","args","radius","smoothness","creaseAngle","steps","ref","children"]);const a=1e-5,j=(d,f,v)=>{const l=new se,_=v-a;return l.absarc(a,a,a,-Math.PI/2,-Math.PI,!0),l.absarc(a,f-_*2,a,Math.PI,Math.PI/2,!0),l.absarc(d-_*2,f-_*2,a,Math.PI/2,0,!0),l.absarc(d-_*2,a,a,0,-Math.PI/2,!0),l};let C=w(()=>n()[0]??1),T=w(()=>n()[1]??1),I=w(()=>n()[2]??1),x=w(()=>j(s(C),s(T),S())),A=w(()=>({depth:s(I)-S()*2,bevelEnabled:!0,bevelSegments:p()*2,steps:g(),bevelSize:S()-a,bevelThickness:S(),curveSegments:p()})),u=w(()=>new re(s(x),s(A)));k(()=>{s(u).center(),ve(s(u),t())}),y(L,W({get is(){return s(u)}},()=>b,{get ref(){return M()},set ref(d){M(d)},children:(d,f)=>{var v=$(),l=F(v);R(l,()=>e.children??H,()=>({ref:s(u)})),U(d,v)},$$slots:{default:!0}})),D()}const be=`uniform float time;
attribute float size;
varying vec3 vColor;
void main() {
	vColor = color;
	vec4 mvPosition = modelViewMatrix * vec4(position, 0.5);
	gl_PointSize = size * (30.0 / -mvPosition.z) * (3.0 + sin(time + 100.0));
	gl_Position = projectionMatrix * mvPosition;
}`;var we=E("<!> <!> <!>",1);function ye(L,e){q(e,!0);let n=i(e,"count",3,5e3),S=i(e,"radius",3,50),p=i(e,"depth",3,50),t=i(e,"factor",3,6),g=i(e,"saturation",3,1),M=i(e,"lightness",3,.8),b=i(e,"speed",3,1),a=i(e,"fade",3,!0),j=i(e,"opacity",3,1),C=i(e,"ref",15),T=J(e,["$$slots","$$events","$$legacy","count","radius","depth","factor","saturation","lightness","speed","fade","opacity","ref","children"]);const I=new oe,x=new X,A=new ce,u=new N,d=c=>x.setFromSpherical(A.set(c,Math.acos(1-Math.random()*2),Math.random()*2*Math.PI)),f=new ne,v=w(()=>new G(new Float32Array(n()*3),3)),l=w(()=>new G(new Float32Array(n()*3),3)),_=w(()=>new G(new Float32Array(n()),1));k(()=>{f.setAttribute("position",s(v)),f.setAttribute("color",s(l)),f.setAttribute("size",s(_))}),k(()=>{const c=p()/n();let B=S()+p();for(let h=0;h<n();h+=1){B-=c*Math.random();const P=d(B);s(v).setXYZ(h,P.x,P.y,P.z),u.setHSL(h/n(),g(),M()),s(l).setXYZ(h,u.r,u.g,u.b),s(_).setX(h,(.5+.5*Math.random())*t())}});const{stop:V,start:o}=Q(c=>{r.time.value+=c*b()},{autoStart:!1});k(()=>b()===0?V():o());const r={time:{value:0},fade:{value:1},opacity:{value:1}},m=new ie({uniforms:r,vertexShader:be,fragmentShader:ge});k(()=>{r.fade.value=a()?1:0}),k(()=>{r.opacity.value=j()}),y(L,W({get is(){return I}},()=>T,{get ref(){return C()},set ref(c){C(c)},children:(c,B)=>{var h=we(),P=F(h);y(P,{get is(){return f}});var O=z(P,2);y(O,{get is(){return m},get blending(){return le},depthWrite:!1,transparent:!0,vertexColors:!0});var K=z(O,2);R(K,()=>e.children??H,()=>({ref:I})),U(c,h)},$$slots:{default:!0}})),D()}var Se=E("<!> <!>",1),xe=E("<!> <!> <!> <!> <!> <!>",1);function Ae(L,e){q(e,!0);const{camera:n,scene:S}=ue(),p=1e3,t=new de(void 0,void 0,p);t.name="cubes",t.frustumCulled=!1,t.castShadow=t.receiveShadow=!0;const g=new X,M=new me,b=new X(1,1,1),a=new fe,j=pe();let C=p-1;const T="#C84C09",I=new N(T);ee(()=>{for(let o=0;o<p;o+=1){const r=(Math.random()-.5)*5,m=r>0?2:-2,c=(Math.random()-.5)*10;g.set(r*2+m,c,-o/2),M.random(),a.compose(g,M,b),t.setMatrixAt(o,a),t.setColorAt(o,Y(I,0))}t.instanceColor&&(t.instanceColor.needsUpdate=!0),t.instanceMatrix.needsUpdate=!0});const x=new he;S.add(x.target);let A=ae(void 0);Q(o=>{n.current.position.z-=o*20,s(A)&&(s(A).position.z=n.current.position.z,x.position.z=n.current.position.z+2,x.target.position.copy(n.current.position));for(let r=0;r<p;r+=1){t.getMatrixAt(r,a),a.decompose(g,M,b);const m=j.logSmooth01[r%128];b.setScalar(Math.max(m/100,.5)),t.setColorAt(r,Y(I.set(T),m/1e3)),g.z>n.current.position.z&&(g.z=-C/2,C+=1),a.compose(g,M,b),t.setMatrixAt(r,a)}t.instanceColor&&(t.instanceColor.needsUpdate=!0),t.instanceMatrix.needsUpdate=!0});var u=xe(),d=F(u);Z(d,()=>y.PerspectiveCamera,(o,r)=>{r(o,{makeDefault:!0,position:[0,.5,5],oncreate:m=>m.lookAt(0,0,.1)})});var f=z(d,2);y(f,{get is(){return x},castShadow:!0,"position.x":2,"position.y":2,intensity:.5});var v=z(f,2);Z(v,()=>y.AmbientLight,(o,r)=>{r(o,{intensity:.5})});var l=z(v,2);y(l,{get is(){return t},children:(o,r)=>{var m=Se(),c=F(m);Me(c,{});var B=z(c,2);Z(B,()=>y.MeshStandardMaterial,(h,P)=>{P(h,{roughness:.05})}),U(o,m)},$$slots:{default:!0}});var _=z(l,2);_e(_,{});var V=z(_,2);ye(V,{get ref(){return s(A)},set ref(o){te(A,o)}}),U(L,u),D()}const Ve=Object.freeze(Object.defineProperty({__proto__:null,default:Ae},Symbol.toStringTag,{value:"Module"}));export{Ae as _,Ve as a};
