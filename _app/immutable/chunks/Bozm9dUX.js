import"./DsnmJJEf.js";import{s as Ve,l as Ce,a3 as ie,ar as q,a6 as H,aa as Fe,a7 as I,a8 as oe,a2 as Me,ag as ge,f as R,a4 as ae,a1 as be,b as ee,a5 as Te,a9 as U}from"./DGLrSMKY.js";import{e as xe}from"./D0C52aKJ.js";import{c as K}from"./CGE0CeKR.js";import{M as ke}from"./CxTOoE5I.js";import{gk as re,ao as ze,g2 as Ae,g3 as Be,g4 as Se,V as _,et as ye,a0 as Y,fD as De,ae as Ee,af as le,x as se,f_ as j,bg as Le,f$ as Re,e1 as je,aV as He,a as Ie,fZ as Ne,ah as Oe}from"./C_yIfSnU.js";import{u as qe,a as Ge,b as Qe,c as we,d as We,e as Ue,R as ve}from"./DrY-w8I1.js";import{k as Ke,w as Ze,A as ce,e as Je}from"./DbMPvVxC.js";import{o as Xe,a as Ye}from"./a6heQtOT.js";import{s as $e}from"./BXYCPDa6.js";import{p as O,a as he,r as et}from"./D7NB5tT8.js";import{i as tt}from"./Br_VAdLV.js";import{u as nt}from"./wM1BCSX6.js";import"./DaUO9hea.js";import{L as st}from"./BkSjAEJK.js";function it(z,e){e&&Ve(re,{...Ce(re),[z]:e})}function _e(z,e){ie(e,!0);let t=O(e,"shape",3,"convexHull"),n=O(e,"colliders",15);const o=new ze,{updateRef:s}=qe(e.oncreate),i=Ge(),a=Qe(),{world:l,addColliderToContext:c,removeColliderFromContext:h}=we(),u=We(),r=()=>{n()!==void 0&&(u.removeColliders(n()),n().forEach(m=>{h(m),l.removeCollider(m,!0)}),n(n().length=0,!0))},g={oncollisionenter:e.oncollisionenter,oncollisionexit:e.oncollisionexit,oncontact:e.oncontact,onsensorenter:e.onsensorenter,onsensorexit:e.onsensorexit},p=()=>{r(),n(Ke(o,t()??"convexHull",l,i,a)),n().forEach(m=>c(m,o,g)),u.registerColliders(n()),n().forEach(m=>{Ue(m,g,i?.userData?.events),m.setActiveCollisionTypes(Ze.ALL),m.setRestitution(e.restitution??0),m.setRestitutionCombineRule(e.restitutionCombineRule??ce.Average),m.setFriction(e.friction??.7),m.setFrictionCombineRule(e.frictionCombineRule??ce.Average),m.setSensor(e.sensor??!1),m.setContactForceEventThreshold(e.contactForceEventThreshold??0),e.density&&m.setDensity(e.density),e.mass&&(e.centerOfMass&&e.principalAngularInertia&&e.angularInertiaLocalFrame?m.setMassProperties(e.mass,{x:e.centerOfMass[0],y:e.centerOfMass[1],z:e.centerOfMass[2]},{x:e.principalAngularInertia[0],y:e.principalAngularInertia[1],z:e.principalAngularInertia[2]},Je(e.angularInertiaLocalFrame)):m.setMass(e.mass))}),s(n())},f=()=>p();Xe(()=>{p()}),Ye(r);const v=Ae();Be(o),Se(v,m=>(m?.add(o),()=>{m?.remove(o)}));var M={refresh:f},A=q(),y=H(A);return $e(y,()=>e.children??Fe,()=>({colliders:n()??[],refresh:f})),I(z,A),oe(M)}const $=0,ot=1,at=new _,ue=new ye,te=new Y,de=new _,X=new De;class rt{constructor(){this.tolerance=-1,this.faces=[],this.newFaces=[],this.assigned=new me,this.unassigned=new me,this.vertices=[]}setFromPoints(e){if(e.length>=4){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.vertices.push(new lt(e[t]));this._compute()}return this}setFromObject(e){const t=[];return e.updateMatrixWorld(!0),e.traverse(function(n){const o=n.geometry;if(o!==void 0){const s=o.attributes.position;if(s!==void 0)for(let i=0,a=s.count;i<a;i++){const l=new _;l.fromBufferAttribute(s,i).applyMatrix4(n.matrixWorld),t.push(l)}}}),this.setFromPoints(t)}containsPoint(e){const t=this.faces;for(let n=0,o=t.length;n<o;n++)if(t[n].distanceToPoint(e)>this.tolerance)return!1;return!0}intersectRay(e,t){const n=this.faces;let o=-1/0,s=1/0;for(let i=0,a=n.length;i<a;i++){const l=n[i],c=l.distanceToPoint(e.origin),h=l.normal.dot(e.direction);if(c>0&&h>=0)return null;const u=h!==0?-c/h:0;if(!(u<=0)&&(h>0?s=Math.min(u,s):o=Math.max(u,o),o>s))return null}return o!==-1/0?e.at(o,t):e.at(s,t),t}intersectsRay(e){return this.intersectRay(e,at)!==null}makeEmpty(){return this.faces=[],this.vertices=[],this}_addVertexToFace(e,t){return e.face=t,t.outside===null?this.assigned.append(e):this.assigned.insertBefore(t.outside,e),t.outside=e,this}_removeVertexFromFace(e,t){return e===t.outside&&(e.next!==null&&e.next.face===t?t.outside=e.next:t.outside=null),this.assigned.remove(e),this}_removeAllVerticesFromFace(e){if(e.outside!==null){const t=e.outside;let n=e.outside;for(;n.next!==null&&n.next.face===e;)n=n.next;return this.assigned.removeSubList(t,n),t.prev=n.next=null,e.outside=null,t}}_deleteFaceVertices(e,t){const n=this._removeAllVerticesFromFace(e);if(n!==void 0)if(t===void 0)this.unassigned.appendChain(n);else{let o=n;do{const s=o.next;t.distanceToPoint(o.point)>this.tolerance?this._addVertexToFace(o,t):this.unassigned.append(o),o=s}while(o!==null)}return this}_resolveUnassignedPoints(e){if(this.unassigned.isEmpty()===!1){let t=this.unassigned.first();do{const n=t.next;let o=this.tolerance,s=null;for(let i=0;i<e.length;i++){const a=e[i];if(a.mark===$){const l=a.distanceToPoint(t.point);if(l>o&&(o=l,s=a),o>1e3*this.tolerance)break}}s!==null&&this._addVertexToFace(t,s),t=n}while(t!==null)}return this}_computeExtremes(){const e=new _,t=new _,n=[],o=[];for(let s=0;s<3;s++)n[s]=o[s]=this.vertices[0];e.copy(this.vertices[0].point),t.copy(this.vertices[0].point);for(let s=0,i=this.vertices.length;s<i;s++){const a=this.vertices[s],l=a.point;for(let c=0;c<3;c++)l.getComponent(c)<e.getComponent(c)&&(e.setComponent(c,l.getComponent(c)),n[c]=a);for(let c=0;c<3;c++)l.getComponent(c)>t.getComponent(c)&&(t.setComponent(c,l.getComponent(c)),o[c]=a)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(e.x),Math.abs(t.x))+Math.max(Math.abs(e.y),Math.abs(t.y))+Math.max(Math.abs(e.z),Math.abs(t.z))),{min:n,max:o}}_computeInitialHull(){const e=this.vertices,t=this._computeExtremes(),n=t.min,o=t.max;let s=0,i=0;for(let r=0;r<3;r++){const g=o[r].point.getComponent(r)-n[r].point.getComponent(r);g>s&&(s=g,i=r)}const a=n[i],l=o[i];let c,h;s=0,ue.set(a.point,l.point);for(let r=0,g=this.vertices.length;r<g;r++){const p=e[r];if(p!==a&&p!==l){ue.closestPointToPoint(p.point,!0,de);const f=de.distanceToSquared(p.point);f>s&&(s=f,c=p)}}s=-1,te.setFromCoplanarPoints(a.point,l.point,c.point);for(let r=0,g=this.vertices.length;r<g;r++){const p=e[r];if(p!==a&&p!==l&&p!==c){const f=Math.abs(te.distanceToPoint(p.point));f>s&&(s=f,h=p)}}const u=[];if(te.distanceToPoint(h.point)<0){u.push(S.create(a,l,c),S.create(h,l,a),S.create(h,c,l),S.create(h,a,c));for(let r=0;r<3;r++){const g=(r+1)%3;u[r+1].getEdge(2).setTwin(u[0].getEdge(g)),u[r+1].getEdge(1).setTwin(u[g+1].getEdge(0))}}else{u.push(S.create(a,c,l),S.create(h,a,l),S.create(h,l,c),S.create(h,c,a));for(let r=0;r<3;r++){const g=(r+1)%3;u[r+1].getEdge(2).setTwin(u[0].getEdge((3-r)%3)),u[r+1].getEdge(0).setTwin(u[g+1].getEdge(1))}}for(let r=0;r<4;r++)this.faces.push(u[r]);for(let r=0,g=e.length;r<g;r++){const p=e[r];if(p!==a&&p!==l&&p!==c&&p!==h){s=this.tolerance;let f=null;for(let v=0;v<4;v++){const M=this.faces[v].distanceToPoint(p.point);M>s&&(s=M,f=this.faces[v])}f!==null&&this._addVertexToFace(p,f)}}return this}_reindexFaces(){const e=[];for(let t=0;t<this.faces.length;t++){const n=this.faces[t];n.mark===$&&e.push(n)}return this.faces=e,this}_nextVertexToAdd(){if(this.assigned.isEmpty()===!1){let e,t=0;const n=this.assigned.first().face;let o=n.outside;do{const s=n.distanceToPoint(o.point);s>t&&(t=s,e=o),o=o.next}while(o!==null&&o.face===n);return e}}_computeHorizon(e,t,n,o){this._deleteFaceVertices(n),n.mark=ot;let s;t===null?s=t=n.getEdge(0):s=t.next;do{const i=s.twin,a=i.face;a.mark===$&&(a.distanceToPoint(e)>this.tolerance?this._computeHorizon(e,i,a,o):o.push(s)),s=s.next}while(s!==t);return this}_addAdjoiningFace(e,t){const n=S.create(e,t.tail(),t.head());return this.faces.push(n),n.getEdge(-1).setTwin(t.twin),n.getEdge(0)}_addNewFaces(e,t){this.newFaces=[];let n=null,o=null;for(let s=0;s<t.length;s++){const i=t[s],a=this._addAdjoiningFace(e,i);n===null?n=a:a.next.setTwin(o),this.newFaces.push(a.face),o=a}return n.next.setTwin(o),this}_addVertexToHull(e){const t=[];return this.unassigned.clear(),this._removeVertexFromFace(e,e.face),this._computeHorizon(e.point,null,e.face,t),this._addNewFaces(e,t),this._resolveUnassignedPoints(this.newFaces),this}_cleanup(){return this.assigned.clear(),this.unassigned.clear(),this.newFaces=[],this}_compute(){let e;for(this._computeInitialHull();(e=this._nextVertexToAdd())!==void 0;)this._addVertexToHull(e);return this._reindexFaces(),this._cleanup(),this}}class S{constructor(){this.normal=new _,this.midpoint=new _,this.area=0,this.constant=0,this.outside=null,this.mark=$,this.edge=null}static create(e,t,n){const o=new S,s=new ne(e,o),i=new ne(t,o),a=new ne(n,o);return s.next=a.prev=i,i.next=s.prev=a,a.next=i.prev=s,o.edge=s,o.compute()}getEdge(e){let t=this.edge;for(;e>0;)t=t.next,e--;for(;e<0;)t=t.prev,e++;return t}compute(){const e=this.edge.tail(),t=this.edge.head(),n=this.edge.next.head();return X.set(e.point,t.point,n.point),X.getNormal(this.normal),X.getMidpoint(this.midpoint),this.area=X.getArea(),this.constant=this.normal.dot(this.midpoint),this}distanceToPoint(e){return this.normal.dot(e)-this.constant}}class ne{constructor(e,t){this.vertex=e,this.prev=null,this.next=null,this.twin=null,this.face=t}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){const e=this.head(),t=this.tail();return t!==null?t.point.distanceTo(e.point):-1}lengthSquared(){const e=this.head(),t=this.tail();return t!==null?t.point.distanceToSquared(e.point):-1}setTwin(e){return this.twin=e,e.twin=this,this}}class lt{constructor(e){this.point=e,this.prev=null,this.next=null,this.face=null}}class me{constructor(){this.head=null,this.tail=null}first(){return this.head}last(){return this.tail}clear(){return this.head=this.tail=null,this}insertBefore(e,t){return t.prev=e.prev,t.next=e,t.prev===null?this.head=t:t.prev.next=t,e.prev=t,this}insertAfter(e,t){return t.prev=e,t.next=e.next,t.next===null?this.tail=t:t.next.prev=t,e.next=t,this}append(e){return this.head===null?this.head=e:this.tail.next=e,e.prev=this.tail,e.next=null,this.tail=e,this}appendChain(e){for(this.head===null?this.head=e:this.tail.next=e,e.prev=this.tail;e.next!==null;)e=e.next;return this.tail=e,this}remove(e){return e.prev===null?this.head=e.next:e.prev.next=e.next,e.next===null?this.tail=e.prev:e.next.prev=e.prev,this}removeSubList(e,t){return e.prev===null?this.head=t.next:e.prev.next=t.next,t.next===null?this.tail=e.prev:t.next.prev=e.prev,this}isEmpty(){return this.head===null}}class fe extends Ee{constructor(e=[]){super();const t=[],n=[],s=new rt().setFromPoints(e).faces;for(let i=0;i<s.length;i++){const a=s[i];let l=a.edge;do{const c=l.head().point;t.push(c.x,c.y,c.z),n.push(a.normal.x,a.normal.y,a.normal.z),l=l.next}while(l!==a.edge)}this.setAttribute("position",new le(t,3)),this.setAttribute("normal",new le(n,3))}}const ct=new _;class Z{constructor(e=1.4,t=1e-4){this.minSizeForBreak=e,this.smallDelta=t,this.tempLine1=new ye,this.tempPlane1=new Y,this.tempPlane2=new Y,this.tempPlane_Cut=new Y,this.tempCM1=new _,this.tempCM2=new _,this.tempVector3=new _,this.tempVector3_2=new _,this.tempVector3_3=new _,this.tempVector3_P0=new _,this.tempVector3_P1=new _,this.tempVector3_P2=new _,this.tempVector3_N0=new _,this.tempVector3_N1=new _,this.tempVector3_AB=new _,this.tempVector3_CB=new _,this.tempResultObjects={object1:null,object2:null},this.segments=[];const n=900;for(let o=0;o<n;o++)this.segments[o]=!1}prepareBreakableObject(e,t,n,o,s){const i=e.userData;i.mass=t,i.velocity=n.clone(),i.angularVelocity=o.clone(),i.breakable=s}subdivideByImpact(e,t,n,o,s){const i=[],a=this.tempPlane1,l=this.tempPlane2;this.tempVector3.addVectors(t,n),a.setFromCoplanarPoints(t,e.position,this.tempVector3);const c=s+o,h=this;function u(r,g,p,f){if(Math.random()<f*.05||f>c){i.push(r);return}let v=Math.PI;f===0?(l.normal.copy(a.normal),l.constant=a.constant):f<=o?(v=(p-g)*(.2+.6*Math.random())+g,h.tempVector3_2.copy(e.position).sub(t).applyAxisAngle(n,v).add(t),l.setFromCoplanarPoints(t,h.tempVector3,h.tempVector3_2)):(v=(.5*(f&1)+.2*(2-Math.random()))*Math.PI,h.tempVector3_2.copy(t).sub(r.position).applyAxisAngle(n,v).add(r.position),h.tempVector3_3.copy(n).add(r.position),l.setFromCoplanarPoints(r.position,h.tempVector3_3,h.tempVector3_2)),h.cutByPlane(r,l,h.tempResultObjects);const M=h.tempResultObjects.object1,A=h.tempResultObjects.object2;M&&u(M,g,v,f+1),A&&u(A,v,p,f+1)}return u(e,0,2*Math.PI,0),i}cutByPlane(e,t,n){const o=e.geometry,s=o.attributes.position.array,i=o.attributes.normal.array,a=s.length/3;let l=a/3,c=o.getIndex();c&&(c=c.array,l=c.length/3);function h(d,x){const C=d*3+x;return c?c[C]:C}const u=[],r=[],g=this.smallDelta,p=a*a;for(let d=0;d<p;d++)this.segments[d]=!1;const f=this.tempVector3_P0,v=this.tempVector3_P1,M=this.tempVector3_N0,A=this.tempVector3_N1;for(let d=0;d<l-1;d++){const x=h(d,0),C=h(d,1),D=h(d,2);M.set(i[x],i[x]+1,i[x]+2);for(let b=d+1;b<l;b++){const k=h(b,0),E=h(b,1),J=h(b,2);A.set(i[k],i[k]+1,i[k]+2),1-M.dot(A)<g&&(x===k||x===E||x===J?C===k||C===E||C===J?(this.segments[x*a+C]=!0,this.segments[C*a+x]=!0):(this.segments[D*a+x]=!0,this.segments[x*a+D]=!0):(C===k||C===E||C===J)&&(this.segments[D*a+C]=!0,this.segments[C*a+D]=!0))}}const y=this.tempPlane_Cut;e.updateMatrix(),Z.transformPlaneToLocalSpace(t,e.matrix,y);for(let d=0;d<l;d++){const x=h(d,0),C=h(d,1),D=h(d,2);for(let b=0;b<3;b++){const k=b===0?x:b===1?C:D,E=b===0?C:b===1?D:x;if(this.segments[k*a+E])continue;this.segments[k*a+E]=!0,this.segments[E*a+k]=!0,f.set(s[3*k],s[3*k+1],s[3*k+2]),v.set(s[3*E],s[3*E+1],s[3*E+2]);let N=0,G=y.distanceToPoint(f);G>g?(N=2,r.push(f.clone())):G<-g?(N=1,u.push(f.clone())):(N=3,u.push(f.clone()),r.push(f.clone()));let Q=0;if(G=y.distanceToPoint(v),G>g?(Q=2,r.push(v.clone())):G<-g?(Q=1,u.push(v.clone())):(Q=3,u.push(v.clone()),r.push(v.clone())),N===1&&Q===2||N===2&&Q===1){this.tempLine1.start.copy(f),this.tempLine1.end.copy(v);let W=new _;if(W=y.intersectLine(this.tempLine1,W),W===null)return console.error("Internal error: segment does not intersect plane."),n.segmentedObject1=null,n.segmentedObject2=null,0;u.push(W),r.push(W.clone())}}}const m=e.userData.mass*.5;this.tempCM1.set(0,0,0);let w=0;const F=u.length;if(F>0){for(let d=0;d<F;d++)this.tempCM1.add(u[d]);this.tempCM1.divideScalar(F);for(let d=0;d<F;d++){const x=u[d];x.sub(this.tempCM1),w=Math.max(w,x.x,x.y,x.z)}this.tempCM1.add(e.position)}this.tempCM2.set(0,0,0);let P=0;const V=r.length;if(V>0){for(let d=0;d<V;d++)this.tempCM2.add(r[d]);this.tempCM2.divideScalar(V);for(let d=0;d<V;d++){const x=r[d];x.sub(this.tempCM2),P=Math.max(P,x.x,x.y,x.z)}this.tempCM2.add(e.position)}let T=null,B=null,L=0;return F>4&&(T=new se(new fe(u),e.material),T.position.copy(this.tempCM1),T.quaternion.copy(e.quaternion),this.prepareBreakableObject(T,m,e.userData.velocity,e.userData.angularVelocity,2*w>this.minSizeForBreak),L++),V>4&&(B=new se(new fe(r),e.material),B.position.copy(this.tempCM2),B.quaternion.copy(e.quaternion),this.prepareBreakableObject(B,m,e.userData.velocity,e.userData.angularVelocity,2*P>this.minSizeForBreak),L++),n.object1=T,n.object2=B,L}static transformFreeVector(e,t){const n=e.x,o=e.y,s=e.z,i=t.elements;return e.x=i[0]*n+i[4]*o+i[8]*s,e.y=i[1]*n+i[5]*o+i[9]*s,e.z=i[2]*n+i[6]*o+i[10]*s,e}static transformFreeVectorInverse(e,t){const n=e.x,o=e.y,s=e.z,i=t.elements;return e.x=i[0]*n+i[1]*o+i[2]*s,e.y=i[4]*n+i[5]*o+i[6]*s,e.z=i[8]*n+i[9]*o+i[10]*s,e}static transformTiedVectorInverse(e,t){const n=e.x,o=e.y,s=e.z,i=t.elements;return e.x=i[0]*n+i[1]*o+i[2]*s-i[12],e.y=i[4]*n+i[5]*o+i[6]*s-i[13],e.z=i[8]*n+i[9]*o+i[10]*s-i[14],e}static transformPlaneToLocalSpace(e,t,n){n.normal.copy(e.normal),n.constant=e.constant;const o=Z.transformTiedVectorInverse(e.coplanarPoint(ct),t);Z.transformFreeVectorInverse(n.normal,t),n.constant=-o.dot(n.normal)}}const pe=new Z;function Pe(z,e){ie(e,!0);let t=O(e,"fixed",3,!1),n=O(e,"depth",3,0),o=O(e,"maxDepth",3,1),s=O(e,"minBreakForce",3,100),i=et(e,["$$slots","$$events","$$legacy","fixed","velocity","angularVelocity","depth","maxDepth","minBreakForce","mesh"]),a=Me(ge([])),l=e.velocity,c=e.angularVelocity,h;n()===0&&pe.prepareBreakableObject(e.mesh,1,new _,new _,!0);let u,r;const g=w=>{if(n()>=o()||w.manifold.numContacts()===0)return;const P=w.manifold.localContactPoint1(0);P&&(u=new _(P.x,P.y,P.z))},p=new _,f=new Le,v=w=>{if(!u)return;if(w.totalForceMagnitude<s()){u=void 0;return}const F=w.maxForceDirection;if(r=new _(F.x,F.y,F.z),h){const V=h.linvel(),T=h.angvel();l=[V.x,V.y,V.z],c=[T.x,T.y,T.z]}be(a,pe.subdivideByImpact(e.mesh,u,r,2,1),!0);const P=e.mesh.parent;if(P){P.getWorldPosition(p),P.getWorldQuaternion(f);for(const V of R(a))V.position.applyQuaternion(f),V.position.add(p),V.quaternion.premultiply(f),V.castShadow=V.receiveShadow=!0,V.material=e.mesh.material.clone()}u=void 0,r=void 0};var M=q(),A=H(M);{var y=w=>{{let F=ae(()=>t()?"fixed":"dynamic");ve(w,{get type(){return R(F)},oncollisionenter:g,oncontact:v,oncreate:P=>{h=P,e.velocity&&P.setLinvel({x:e.velocity[0],y:e.velocity[1],z:e.velocity[2]},!0),e.angularVelocity&&P.setAngvel({x:e.angularVelocity[0],y:e.angularVelocity[1],z:e.angularVelocity[2]},!0)},canSleep:!1,children:(P,V)=>{_e(P,{shape:"convexHull",children:(T,B)=>{j(T,he({get is(){return e.mesh}},()=>i))},$$slots:{default:!0}})},$$slots:{default:!0}})}},m=w=>{var F=q(),P=H(F);xe(P,17,()=>R(a),V=>V.uuid,(V,T)=>{var B=q(),L=H(B);K(L,()=>j.Group,(d,x)=>{x(d,{scale:.98,children:(C,D)=>{{let b=ae(()=>n()+1);Pe(C,he({get mesh(){return R(T)},get depth(){return R(b)},get maxDepth(){return o()},get minBreakForce(){return s()},get velocity(){return l},get angularVelocity(){return c}},()=>i))}},$$slots:{default:!0}})}),I(V,B)}),I(w,F)};tt(A,w=>{R(a).length===0?w(y):w(m,!1)})}I(z,M),oe()}var ht=Te("<!> <!> <!> <!> <!> <!>",1);function ut(z,e){ie(e,!0);const{scene:t}=Re(),{world:n}=we(),o=nt(),s=()=>{const y=new ke;y.roughness=.1;const m=new Oe,w=new se(m,y);return w.castShadow=w.receiveShadow=!0,w.visible=!1,w.quaternion.random(),w};let i=ge([s()]);ee(()=>{const{y}=n.gravity;return n.gravity.y=0,()=>n.gravity.y=y}),ee(()=>(t.fog=new je("#000",2,20),()=>t.fog=null));const a=new He;let l=performance.now(),c=performance.now();const h=new Ie;Ne(y=>{if(l+=y,o.level>.012&&l-c>2&&(c=l,i.push(s()),i.length>10&&i.shift()),o.level>.002){const m=[...u],w=m.length,F=m[Math.random()*w|0];if(F){const P=F.material;h.setHSL(Math.random(),1,.6),P.color.set(h)}}});const u=new Set;it("color",y=>{y.ref.isMesh&&ee(()=>(u.add(y.ref),()=>u.delete(y.ref)))});var r=ht(),g=H(r);K(g,()=>j.PerspectiveCamera,(y,m)=>{m(y,{makeDefault:!0,"position.y":1,"position.z":10,oncreate:w=>w.lookAt(0,0,0)})});var p=U(g,2);j(p,{get is(){return a},intensity:3,position:[5,5,5],castShadow:!0,"shadow.camera.left":-5,"shadow.camera.right":5,"shadow.camera.top":5,"shadow.camera.bottom":-5,"shadow.mapSize.width":4096,"shadow.mapSize.height":4096});var f=U(p,2);K(f,()=>j.AmbientLight,(y,m)=>{m(y,{intensity:.1})});var v=U(f,2);xe(v,17,()=>i,y=>y.uuid,(y,m)=>{Pe(y,{get mesh(){return R(m)},autoBreak:!0,minBreakForce:0,maxDepth:2})});var M=U(v,2);ve(M,{type:"fixed",children:(y,m)=>{_e(y,{shape:"cuboid",children:(w,F)=>{var P=q(),V=H(P);K(V,()=>j.Mesh,(T,B)=>{B(T,{visible:!1,children:(L,d)=>{var x=q(),C=H(x);K(C,()=>j.BoxGeometry,(D,b)=>{b(D,{args:[.05,.05,.05]})}),I(L,x)},$$slots:{default:!0}})}),I(w,P)},$$slots:{default:!0}})},$$slots:{default:!0}});var A=U(M,2);st(A,{}),I(z,r),oe()}const bt=Object.freeze(Object.defineProperty({__proto__:null,default:ut},Symbol.toStringTag,{value:"Module"}));export{ut as _,bt as a};
