import"./disclose-version.Bg9kRutz.js";import{p as ie,a9 as Pe,ab as Fe,f as R,a2 as Ce,a as oe,a5 as Me,k as j,a6 as Ve,m as re,d as le,s as Q}from"./index-client.DzQlphmH.js";import{c as J,a as I,t as ae}from"./template.CgCchT00.js";import{e as ge,i as _e}from"./each.C8O1i2N9.js";import{c as U}from"./svelte-component.D0WKzo0g.js";import{p as O,a as ne,s as be,r as Te}from"./props.DHXOHPV0.js";import{V as w,a4 as xe,P as Z,bj as ke,p as De,F as ce,M as se,G as Se,H as Ae,J as Ee,K as Be,s as ze,d as H,Q as Le,i as Re,C as Ie,aR as je,u as He,a$ as Ne,a8 as Oe,bi as qe}from"./T.D9_Xg1XW.js";import{W as Ge}from"./World.CRBzvZon.js";import{u as We,a as Qe,b as Ue,c as Je,d as Ke,l as Xe,f as Ye,o as Ze,A as he,e as $e,i as we}from"./createCollidersFromChildren.CGFyc-A4.js";import{i as et}from"./if.Cf1I8q-8.js";import{L as tt}from"./Lightformer.DPT4bBXl.js";import{a as nt}from"./auth.svelte.BAHdEbOi.js";import{l as st}from"./MathUtils.DS64O8Kj.js";const $=0,it=1,ot=new w,ue=new xe,ee=new Z,de=new w,Y=new ke;class at{constructor(){this.tolerance=-1,this.faces=[],this.newFaces=[],this.assigned=new me,this.unassigned=new me,this.vertices=[]}setFromPoints(e){if(e.length>=4){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.vertices.push(new rt(e[t]));this.compute()}return this}setFromObject(e){const t=[];return e.updateMatrixWorld(!0),e.traverse(function(n){const o=n.geometry;if(o!==void 0){const s=o.attributes.position;if(s!==void 0)for(let i=0,r=s.count;i<r;i++){const l=new w;l.fromBufferAttribute(s,i).applyMatrix4(n.matrixWorld),t.push(l)}}}),this.setFromPoints(t)}containsPoint(e){const t=this.faces;for(let n=0,o=t.length;n<o;n++)if(t[n].distanceToPoint(e)>this.tolerance)return!1;return!0}intersectRay(e,t){const n=this.faces;let o=-1/0,s=1/0;for(let i=0,r=n.length;i<r;i++){const l=n[i],c=l.distanceToPoint(e.origin),h=l.normal.dot(e.direction);if(c>0&&h>=0)return null;const f=h!==0?-c/h:0;if(!(f<=0)&&(h>0?s=Math.min(f,s):o=Math.max(f,o),o>s))return null}return o!==-1/0?e.at(o,t):e.at(s,t),t}intersectsRay(e){return this.intersectRay(e,ot)!==null}makeEmpty(){return this.faces=[],this.vertices=[],this}addVertexToFace(e,t){return e.face=t,t.outside===null?this.assigned.append(e):this.assigned.insertBefore(t.outside,e),t.outside=e,this}removeVertexFromFace(e,t){return e===t.outside&&(e.next!==null&&e.next.face===t?t.outside=e.next:t.outside=null),this.assigned.remove(e),this}removeAllVerticesFromFace(e){if(e.outside!==null){const t=e.outside;let n=e.outside;for(;n.next!==null&&n.next.face===e;)n=n.next;return this.assigned.removeSubList(t,n),t.prev=n.next=null,e.outside=null,t}}deleteFaceVertices(e,t){const n=this.removeAllVerticesFromFace(e);if(n!==void 0)if(t===void 0)this.unassigned.appendChain(n);else{let o=n;do{const s=o.next;t.distanceToPoint(o.point)>this.tolerance?this.addVertexToFace(o,t):this.unassigned.append(o),o=s}while(o!==null)}return this}resolveUnassignedPoints(e){if(this.unassigned.isEmpty()===!1){let t=this.unassigned.first();do{const n=t.next;let o=this.tolerance,s=null;for(let i=0;i<e.length;i++){const r=e[i];if(r.mark===$){const l=r.distanceToPoint(t.point);if(l>o&&(o=l,s=r),o>1e3*this.tolerance)break}}s!==null&&this.addVertexToFace(t,s),t=n}while(t!==null)}return this}computeExtremes(){const e=new w,t=new w,n=[],o=[];for(let s=0;s<3;s++)n[s]=o[s]=this.vertices[0];e.copy(this.vertices[0].point),t.copy(this.vertices[0].point);for(let s=0,i=this.vertices.length;s<i;s++){const r=this.vertices[s],l=r.point;for(let c=0;c<3;c++)l.getComponent(c)<e.getComponent(c)&&(e.setComponent(c,l.getComponent(c)),n[c]=r);for(let c=0;c<3;c++)l.getComponent(c)>t.getComponent(c)&&(t.setComponent(c,l.getComponent(c)),o[c]=r)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(e.x),Math.abs(t.x))+Math.max(Math.abs(e.y),Math.abs(t.y))+Math.max(Math.abs(e.z),Math.abs(t.z))),{min:n,max:o}}computeInitialHull(){const e=this.vertices,t=this.computeExtremes(),n=t.min,o=t.max;let s=0,i=0;for(let a=0;a<3;a++){const p=o[a].point.getComponent(a)-n[a].point.getComponent(a);p>s&&(s=p,i=a)}const r=n[i],l=o[i];let c,h;s=0,ue.set(r.point,l.point);for(let a=0,p=this.vertices.length;a<p;a++){const d=e[a];if(d!==r&&d!==l){ue.closestPointToPoint(d.point,!0,de);const g=de.distanceToSquared(d.point);g>s&&(s=g,c=d)}}s=-1,ee.setFromCoplanarPoints(r.point,l.point,c.point);for(let a=0,p=this.vertices.length;a<p;a++){const d=e[a];if(d!==r&&d!==l&&d!==c){const g=Math.abs(ee.distanceToPoint(d.point));g>s&&(s=g,h=d)}}const f=[];if(ee.distanceToPoint(h.point)<0){f.push(k.create(r,l,c),k.create(h,l,r),k.create(h,c,l),k.create(h,r,c));for(let a=0;a<3;a++){const p=(a+1)%3;f[a+1].getEdge(2).setTwin(f[0].getEdge(p)),f[a+1].getEdge(1).setTwin(f[p+1].getEdge(0))}}else{f.push(k.create(r,c,l),k.create(h,r,l),k.create(h,l,c),k.create(h,c,r));for(let a=0;a<3;a++){const p=(a+1)%3;f[a+1].getEdge(2).setTwin(f[0].getEdge((3-a)%3)),f[a+1].getEdge(0).setTwin(f[p+1].getEdge(1))}}for(let a=0;a<4;a++)this.faces.push(f[a]);for(let a=0,p=e.length;a<p;a++){const d=e[a];if(d!==r&&d!==l&&d!==c&&d!==h){s=this.tolerance;let g=null;for(let v=0;v<4;v++){const C=this.faces[v].distanceToPoint(d.point);C>s&&(s=C,g=this.faces[v])}g!==null&&this.addVertexToFace(d,g)}}return this}reindexFaces(){const e=[];for(let t=0;t<this.faces.length;t++){const n=this.faces[t];n.mark===$&&e.push(n)}return this.faces=e,this}nextVertexToAdd(){if(this.assigned.isEmpty()===!1){let e,t=0;const n=this.assigned.first().face;let o=n.outside;do{const s=n.distanceToPoint(o.point);s>t&&(t=s,e=o),o=o.next}while(o!==null&&o.face===n);return e}}computeHorizon(e,t,n,o){this.deleteFaceVertices(n),n.mark=it;let s;t===null?s=t=n.getEdge(0):s=t.next;do{const i=s.twin,r=i.face;r.mark===$&&(r.distanceToPoint(e)>this.tolerance?this.computeHorizon(e,i,r,o):o.push(s)),s=s.next}while(s!==t);return this}addAdjoiningFace(e,t){const n=k.create(e,t.tail(),t.head());return this.faces.push(n),n.getEdge(-1).setTwin(t.twin),n.getEdge(0)}addNewFaces(e,t){this.newFaces=[];let n=null,o=null;for(let s=0;s<t.length;s++){const i=t[s],r=this.addAdjoiningFace(e,i);n===null?n=r:r.next.setTwin(o),this.newFaces.push(r.face),o=r}return n.next.setTwin(o),this}addVertexToHull(e){const t=[];return this.unassigned.clear(),this.removeVertexFromFace(e,e.face),this.computeHorizon(e.point,null,e.face,t),this.addNewFaces(e,t),this.resolveUnassignedPoints(this.newFaces),this}cleanup(){return this.assigned.clear(),this.unassigned.clear(),this.newFaces=[],this}compute(){let e;for(this.computeInitialHull();(e=this.nextVertexToAdd())!==void 0;)this.addVertexToHull(e);return this.reindexFaces(),this.cleanup(),this}}class k{constructor(){this.normal=new w,this.midpoint=new w,this.area=0,this.constant=0,this.outside=null,this.mark=$,this.edge=null}static create(e,t,n){const o=new k,s=new te(e,o),i=new te(t,o),r=new te(n,o);return s.next=r.prev=i,i.next=s.prev=r,r.next=i.prev=s,o.edge=s,o.compute()}getEdge(e){let t=this.edge;for(;e>0;)t=t.next,e--;for(;e<0;)t=t.prev,e++;return t}compute(){const e=this.edge.tail(),t=this.edge.head(),n=this.edge.next.head();return Y.set(e.point,t.point,n.point),Y.getNormal(this.normal),Y.getMidpoint(this.midpoint),this.area=Y.getArea(),this.constant=this.normal.dot(this.midpoint),this}distanceToPoint(e){return this.normal.dot(e)-this.constant}}class te{constructor(e,t){this.vertex=e,this.prev=null,this.next=null,this.twin=null,this.face=t}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){const e=this.head(),t=this.tail();return t!==null?t.point.distanceTo(e.point):-1}lengthSquared(){const e=this.head(),t=this.tail();return t!==null?t.point.distanceToSquared(e.point):-1}setTwin(e){return this.twin=e,e.twin=this,this}}class rt{constructor(e){this.point=e,this.prev=null,this.next=null,this.face=null}}class me{constructor(){this.head=null,this.tail=null}first(){return this.head}last(){return this.tail}clear(){return this.head=this.tail=null,this}insertBefore(e,t){return t.prev=e.prev,t.next=e,t.prev===null?this.head=t:t.prev.next=t,e.prev=t,this}insertAfter(e,t){return t.prev=e,t.next=e.next,t.next===null?this.tail=t:t.next.prev=t,e.next=t,this}append(e){return this.head===null?this.head=e:this.tail.next=e,e.prev=this.tail,e.next=null,this.tail=e,this}appendChain(e){for(this.head===null?this.head=e:this.tail.next=e,e.prev=this.tail;e.next!==null;)e=e.next;return this.tail=e,this}remove(e){return e.prev===null?this.head=e.next:e.prev.next=e.next,e.next===null?this.tail=e.prev:e.next.prev=e.prev,this}removeSubList(e,t){return e.prev===null?this.head=t.next:e.prev.next=t.next,t.next===null?this.tail=e.prev:t.next.prev=e.prev,this}isEmpty(){return this.head===null}}class fe extends De{constructor(e=[]){super();const t=[],n=[],s=new at().setFromPoints(e).faces;for(let i=0;i<s.length;i++){const r=s[i];let l=r.edge;do{const c=l.head().point;t.push(c.x,c.y,c.z),n.push(r.normal.x,r.normal.y,r.normal.z),l=l.next}while(l!==r.edge)}this.setAttribute("position",new ce(t,3)),this.setAttribute("normal",new ce(n,3))}}const lt=new w;class K{constructor(e=1.4,t=1e-4){this.minSizeForBreak=e,this.smallDelta=t,this.tempLine1=new xe,this.tempPlane1=new Z,this.tempPlane2=new Z,this.tempPlane_Cut=new Z,this.tempCM1=new w,this.tempCM2=new w,this.tempVector3=new w,this.tempVector3_2=new w,this.tempVector3_3=new w,this.tempVector3_P0=new w,this.tempVector3_P1=new w,this.tempVector3_P2=new w,this.tempVector3_N0=new w,this.tempVector3_N1=new w,this.tempVector3_AB=new w,this.tempVector3_CB=new w,this.tempResultObjects={object1:null,object2:null},this.segments=[];const n=30*30;for(let o=0;o<n;o++)this.segments[o]=!1}prepareBreakableObject(e,t,n,o,s){const i=e.userData;i.mass=t,i.velocity=n.clone(),i.angularVelocity=o.clone(),i.breakable=s}subdivideByImpact(e,t,n,o,s){const i=[],r=this.tempPlane1,l=this.tempPlane2;this.tempVector3.addVectors(t,n),r.setFromCoplanarPoints(t,e.position,this.tempVector3);const c=s+o,h=this;function f(a,p,d,g){if(Math.random()<g*.05||g>c){i.push(a);return}let v=Math.PI;g===0?(l.normal.copy(r.normal),l.constant=r.constant):g<=o?(v=(d-p)*(.2+.6*Math.random())+p,h.tempVector3_2.copy(e.position).sub(t).applyAxisAngle(n,v).add(t),l.setFromCoplanarPoints(t,h.tempVector3,h.tempVector3_2)):(v=(.5*(g&1)+.2*(2-Math.random()))*Math.PI,h.tempVector3_2.copy(t).sub(a.position).applyAxisAngle(n,v).add(a.position),h.tempVector3_3.copy(n).add(a.position),l.setFromCoplanarPoints(a.position,h.tempVector3_3,h.tempVector3_2)),h.cutByPlane(a,l,h.tempResultObjects);const C=h.tempResultObjects.object1,y=h.tempResultObjects.object2;C&&f(C,p,v,g+1),y&&f(y,v,d,g+1)}return f(e,0,2*Math.PI,0),i}cutByPlane(e,t,n){const o=e.geometry,s=o.attributes.position.array,i=o.attributes.normal.array,r=s.length/3;let l=r/3,c=o.getIndex();c&&(c=c.array,l=c.length/3);function h(m,x){const P=m*3+x;return c?c[P]:P}const f=[],a=[],p=this.smallDelta,d=r*r;for(let m=0;m<d;m++)this.segments[m]=!1;const g=this.tempVector3_P0,v=this.tempVector3_P1,C=this.tempVector3_N0,y=this.tempVector3_N1;for(let m=0;m<l-1;m++){const x=h(m,0),P=h(m,1),T=h(m,2);C.set(i[x],i[x]+1,i[x]+2);for(let _=m+1;_<l;_++){const V=h(_,0),S=h(_,1),X=h(_,2);y.set(i[V],i[V]+1,i[V]+2),1-C.dot(y)<p&&(x===V||x===S||x===X?P===V||P===S||P===X?(this.segments[x*r+P]=!0,this.segments[P*r+x]=!0):(this.segments[T*r+x]=!0,this.segments[x*r+T]=!0):(P===V||P===S||P===X)&&(this.segments[T*r+P]=!0,this.segments[P*r+T]=!0))}}const u=this.tempPlane_Cut;e.updateMatrix(),K.transformPlaneToLocalSpace(t,e.matrix,u);for(let m=0;m<l;m++){const x=h(m,0),P=h(m,1),T=h(m,2);for(let _=0;_<3;_++){const V=_===0?x:_===1?P:T,S=_===0?P:_===1?T:x;if(this.segments[V*r+S])continue;this.segments[V*r+S]=!0,this.segments[S*r+V]=!0,g.set(s[3*V],s[3*V+1],s[3*V+2]),v.set(s[3*S],s[3*S+1],s[3*S+2]);let N=0,q=u.distanceToPoint(g);q>p?(N=2,a.push(g.clone())):q<-p?(N=1,f.push(g.clone())):(N=3,f.push(g.clone()),a.push(g.clone()));let G=0;if(q=u.distanceToPoint(v),q>p?(G=2,a.push(v.clone())):q<-p?(G=1,f.push(v.clone())):(G=3,f.push(v.clone()),a.push(v.clone())),N===1&&G===2||N===2&&G===1){this.tempLine1.start.copy(g),this.tempLine1.end.copy(v);let W=new w;if(W=u.intersectLine(this.tempLine1,W),W===null)return console.error("Internal error: segment does not intersect plane."),n.segmentedObject1=null,n.segmentedObject2=null,0;f.push(W),a.push(W.clone())}}}const F=e.userData.mass*.5;this.tempCM1.set(0,0,0);let M=0;const b=f.length;if(b>0){for(let m=0;m<b;m++)this.tempCM1.add(f[m]);this.tempCM1.divideScalar(b);for(let m=0;m<b;m++){const x=f[m];x.sub(this.tempCM1),M=Math.max(M,x.x,x.y,x.z)}this.tempCM1.add(e.position)}this.tempCM2.set(0,0,0);let A=0;const E=a.length;if(E>0){for(let m=0;m<E;m++)this.tempCM2.add(a[m]);this.tempCM2.divideScalar(E);for(let m=0;m<E;m++){const x=a[m];x.sub(this.tempCM2),A=Math.max(A,x.x,x.y,x.z)}this.tempCM2.add(e.position)}let B=null,z=null,L=0;return b>4&&(B=new se(new fe(f),e.material),B.position.copy(this.tempCM1),B.quaternion.copy(e.quaternion),this.prepareBreakableObject(B,F,e.userData.velocity,e.userData.angularVelocity,2*M>this.minSizeForBreak),L++),E>4&&(z=new se(new fe(a),e.material),z.position.copy(this.tempCM2),z.quaternion.copy(e.quaternion),this.prepareBreakableObject(z,F,e.userData.velocity,e.userData.angularVelocity,2*A>this.minSizeForBreak),L++),n.object1=B,n.object2=z,L}static transformFreeVector(e,t){const n=e.x,o=e.y,s=e.z,i=t.elements;return e.x=i[0]*n+i[4]*o+i[8]*s,e.y=i[1]*n+i[5]*o+i[9]*s,e.z=i[2]*n+i[6]*o+i[10]*s,e}static transformFreeVectorInverse(e,t){const n=e.x,o=e.y,s=e.z,i=t.elements;return e.x=i[0]*n+i[1]*o+i[2]*s,e.y=i[4]*n+i[5]*o+i[6]*s,e.z=i[8]*n+i[9]*o+i[10]*s,e}static transformTiedVectorInverse(e,t){const n=e.x,o=e.y,s=e.z,i=t.elements;return e.x=i[0]*n+i[1]*o+i[2]*s-i[12],e.y=i[4]*n+i[5]*o+i[6]*s-i[13],e.z=i[8]*n+i[9]*o+i[10]*s-i[14],e}static transformPlaneToLocalSpace(e,t,n){n.normal.copy(e.normal),n.constant=e.constant;const o=K.transformTiedVectorInverse(e.coplanarPoint(lt),t);K.transformFreeVectorInverse(n.normal,t),n.constant=-o.dot(n.normal)}}function ve(D,e){ie(e,!0);let t=O(e,"shape",3,"convexHull"),n=O(e,"colliders",15);const o=new Se,{updateRef:s}=We(e.oncreate),i=Qe(),r=Ue(),{world:l,addColliderToContext:c,removeColliderFromContext:h}=Je(),f=Ke(),a=()=>{n()!==void 0&&(f.removeColliders(n()),n().forEach(u=>{h(u),l.removeCollider(u,!0)}),n(n().length=0,!0))},p={oncollisionenter:e.oncollisionenter,oncollisionexit:e.oncollisionexit,oncontact:e.oncontact,onsensorenter:e.onsensorenter,onsensorexit:e.onsensorexit},d=()=>{a(),n(Xe(o,t()??"convexHull",l,i,r)),n().forEach(u=>c(u,o,p)),f.registerColliders(n()),n().forEach(u=>{var F;Ye(u,p,(F=i==null?void 0:i.userData)==null?void 0:F.events),u.setActiveCollisionTypes(Ze.ALL),u.setRestitution(e.restitution??0),u.setRestitutionCombineRule(e.restitutionCombineRule??he.Average),u.setFriction(e.friction??.7),u.setFrictionCombineRule(e.frictionCombineRule??he.Average),u.setSensor(e.sensor??!1),u.setContactForceEventThreshold(e.contactForceEventThreshold??0),e.density&&u.setDensity(e.density),e.mass&&(e.centerOfMass&&e.principalAngularInertia&&e.angularInertiaLocalFrame?u.setMassProperties(e.mass,{x:e.centerOfMass[0],y:e.centerOfMass[1],z:e.centerOfMass[2]},{x:e.principalAngularInertia[0],y:e.principalAngularInertia[1],z:e.principalAngularInertia[2]},$e(e.angularInertiaLocalFrame)):u.setMass(e.mass))}),s(n())},g=()=>d();Pe(()=>{d()}),Fe(a);const v=Ae();Ee(o),Be(v,u=>(u==null||u.add(o),()=>{u==null||u.remove(o)}));var C=J(),y=R(C);return ze(y,()=>e.children??Ce,()=>({colliders:n()??[],refresh:g})),I(D,C),oe({refresh:g})}const pe=new K;function ye(D,e){ie(e,!0);let t=O(e,"fixed",3,!1),n=O(e,"depth",3,0),o=O(e,"maxDepth",3,1),s=O(e,"minBreakForce",3,100),i=Te(e,["$$slots","$$events","$$legacy","fixed","depth","maxDepth","minBreakForce","mesh"]),r=Me(ne([]));n()===0&&pe.prepareBreakableObject(e.mesh,1,new w,new w,!0);let l,c;const h=y=>{if(n()>=o()||y.manifold.numContacts()===0)return;const F=y.manifold.localContactPoint1(0);F&&(l=new w(F.x,F.y,F.z))},f=new w,a=new Le;new w;const p=y=>{if(!l)return;if(y.totalForceMagnitude<s()){l=void 0;return}const u=y.maxForceDirection;c=new w(u.x,u.y,u.z),Ve(r,ne(pe.subdivideByImpact(e.mesh,l,c,2,1)));const F=e.mesh.parent;F.getWorldPosition(f),F.getWorldQuaternion(a);for(const M of j(r))M.quaternion.copy(a),M.position.add(f),M.castShadow=M.receiveShadow=!0};var d=J(),g=R(d);{var v=y=>{var u=re(()=>t()?"fixed":"dynamic");we(y,be({get type(){return j(u)},oncollisionenter:h,oncontact:p,canSleep:!1},()=>i,{children:(F,M)=>{ve(F,{shape:"convexHull",children:(b,A)=>{H(b,{get is(){return e.mesh}})},$$slots:{default:!0}})},$$slots:{default:!0}}))},C=y=>{var u=J(),F=R(u);ge(F,17,()=>j(r),M=>M.uuid,(M,b)=>{var A=J(),E=R(A);U(E,()=>H.Group,(B,z)=>{z(B,{scale:.98,children:(L,m)=>{var x=re(()=>n()+1);ye(L,{get mesh(){return j(b)},get depth(){return j(x)},get maxDepth(){return o()},get minBreakForce(){return s()}})},$$slots:{default:!0}})}),I(M,A)}),I(y,u)};et(g,y=>{j(r).length===0?y(v):y(C,!1)})}I(D,d),oe()}var ct=ae("<!> <!>",1),ht=ae("<!> <!>",1),ut=ae("<!> <!> <!> <!>",1);function dt(D,e){ie(e,!0);const{scene:t}=Re(),{frequencyData:n}=nt(),o=()=>{const a=new Ne;a.roughness=.1;const p=new Oe,d=new se(p,a);return d.castShadow=d.receiveShadow=!0,d.position.y=3,d};let s=ne([o()]);le(()=>{const a=setInterval(()=>s.push(o()),2e4);return()=>clearInterval(a)}),le(()=>(t.fog=new qe("#000",2,10),()=>t.fog=null)),new Ie("#FF4F4F");const i=new je;He(a=>{const p=n.current[16]/200;i.intensity=Math.min(1,Math.max(st(p,0,2*a),.5))});var r=ut(),l=R(r);U(l,()=>H.PerspectiveCamera,(a,p)=>{p(a,{makeDefault:!0,"position.y":1,"position.z":5,oncreate:d=>d.lookAt(0,0,0)})});var c=Q(l,2);H(c,{is:i,intensity:.5,position:[1,1,1],castShadow:!0});var h=Q(c,2);Ge(h,{gravity:[0,-1,0],children:(a,p)=>{var d=ht(),g=R(d);ge(g,17,()=>s,_e,(C,y)=>{ye(C,{get mesh(){return j(y)},minBreakForce:.1,maxDepth:2})});var v=Q(g,2);we(v,{type:"fixed",children:(C,y)=>{ve(C,{shape:"cuboid",children:(u,F)=>{var M=J(),b=R(M);U(b,()=>H.Mesh,(A,E)=>{E(A,{"position.y":-1,receiveShadow:!0,children:(B,z)=>{var L=ct(),m=R(L);U(m,()=>H.BoxGeometry,(P,T)=>{T(P,{args:[20,.1,20]})});var x=Q(m,2);U(x,()=>H.MeshStandardMaterial,(P,T)=>{T(P,{roughness:.1})}),I(B,L)},$$slots:{default:!0}})}),I(u,M)},$$slots:{default:!0}})},$$slots:{default:!0}}),I(a,d)},$$slots:{default:!0}});var f=Q(h,2);tt(f,{}),I(D,r),oe()}const _t=Object.freeze(Object.defineProperty({__proto__:null,default:dt},Symbol.toStringTag,{value:"Module"}));export{dt as _,_t as a};
